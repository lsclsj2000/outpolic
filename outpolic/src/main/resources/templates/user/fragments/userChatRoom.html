<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<div class="SR_bg-white SR_d-flex SR_align-items-center SR_justify-content-center SR_min-vh-100" th:fragment="userChatRoomFragment">
	<!-- 수정중 -->
    <div id="chat-float-button-container" class="SR_chat-float-button"></div>

    <div id="chat-window-container"></div>

    <div id="modal-container"></div>
    <div id="custom-input-modal-container"></div>

    <script type="module">
        // Firebase CDN Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, addDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, where, orderBy, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global state variables
        let app;
        let db;
        let auth;
        let userId = null; // User ID set after authentication
        let isAuthReady = false; // Flag to indicate Firebase auth is ready

        // Application state object
        let state = {
            isChatOpen: false, // Chat window open/closed status
            currentView: 'home', // Current view: 'home', 'chatRooms' (list) or 'chatMessages' (messages) - changed default to 'home'
            selectedRoomId: null, // Currently selected chat room ID
            selectedOpponentId: null, // New: Stores the ID of the selected opponent for profile view
            chatRooms: [], // Chat room data (filled with dummy data or real data)
            messages: [], // Messages for the current chat room
            firestoreListeners: [], // Array to store unsubscribe functions for Firestore listeners
            isMaximized: false // New state for chat window maximization
        };

        // Firebase configuration (provided by Canvas environment)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        // FIX: Corrected the ReferenceError by directly using the global __initial_auth_token
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Gemini AI Assistant unique ID (to differentiate from other user IDs)
        const AI_ASSISTANT_ID = "gemini-ai-assistant";
        const AI_ASSISTANT_NAME = "AI 도우미 ✨";

        // Dummy Data for Portfolio and Outsourcing
        const dummyPortfolios = [
            { id: 'p1', title: '웹사이트 개발 프로젝트 (대규모)', description: '반응형 웹사이트 및 백엔드 시스템 구축. 최신 웹 기술 스택을 활용하여 확장성과 안정성을 보장합니다.', imageUrl: 'https://placehold.co/180x120/abc123/ffffff?text=웹사이트' },
            { id: 'p2', title: '모바일 앱 UI/UX 디자인 (혁신적)', description: '사용자 중심의 직관적인 인터페이스 설계 및 디자인 시스템 구축으로 사용자 만족도를 극대화합니다.', imageUrl: 'https://placehold.co/180x120/def456/ffffff?text=모바일앱' },
            { id: 'p3', title: '데이터 분석 대시보드 (실시간)', description: '대용량 데이터의 실시간 수집 및 시각화, 인사이트 도출을 위한 고급 분석 대시보드 솔루션입니다.', imageUrl: 'https://placehold.co/180x120/789ghi/ffffff?text=데이터분석' },
            { id: 'p4', title: 'AI 기반 챗봇 솔루션 (맞춤형)', description: '자연어 처리 및 머신러닝 기술을 활용한 지능형 챗봇 개발로 고객 응대 자동화 및 효율성을 높입니다.', imageUrl: 'https://placehold.co/180x120/jkl012/ffffff?text=AI챗봇' },
            { id: 'p5', title: '클라우드 인프라 구축 (안정성)', description: 'AWS 기반의 고가용성 및 확장 가능한 클라우드 인프라를 설계하고 구축하여 안정적인 서비스 운영을 지원합니다.', imageUrl: 'https://placehold.co/180x120/mno345/ffffff?text=클라우드' },
            { id: 'p6', title: '게임 개발 프레임워크', description: '크로스 플랫폼 게임 개발을 위한 강력한 프레임워크 설계', imageUrl: 'https://placehold.co/180x120/456def/ffffff?text=게임개발' }
        ];

        const dummyOutsourcings = [
            { id: 'o1', title: '신규 서비스 랜딩 페이지 제작', description: '신규 서비스 런칭을 위한 마케팅용 고성능 랜딩 페이지 개발이 필요합니다.', status: '진행 중' },
            { id: 'o2', title: '재고 관리 시스템 개발 의뢰', description: '소상공인을 위한 맞춤형 클라우드 기반 재고 관리 시스템 개발을 의뢰합니다.', status: '대기 중' },
            { id: 'o3', title: 'ERP 시스템 모듈 연동 및 커스터마이징', description: '기존 ERP에 신규 모듈 연동 및 기업 특성에 맞는 기능 커스터마이징 프로젝트입니다.', status: '완료' },
            { id: 'o4', title: '컨텐츠 관리 시스템 고도화 개발', description: '기존 컨텐츠 관리 시스템에 이미지 및 비디오 처리 기능 강화를 위한 고도화 개발을 요청합니다.', status: '진행 중' },
            { id: 'o5', title: '사내 교육 플랫폼 구축', description: '직원 교육을 위한 인터랙티브 온라인 교육 플랫폼 구축 프로젝트입니다.', status: '진행 중' },
            { id: 'o6', title: '보안 솔루션 도입 컨설팅', description: '기업 데이터 보안 강화를 위한 전문가 컨설팅 및 솔루션 도입을 희망합니다.', status: '대기 중' }
        ];

        // Dummy Profile Data for other users (for opponent profile view)
        const dummyUserProfiles = {
            'dummyUser2': { name: '이팀장', company: 'ABC 솔루션', description: '프로젝트 관리 및 기획 전문가입니다.', profileImageUrl: 'https://placehold.co/80x80/6366f1/ffffff?text=이팀장' },
            'dummyUser3': { name: '최대리', company: 'XYZ 디자인', description: '창의적인 UI/UX 디자인을 담당합니다.', profileImageUrl: 'https://placehold.co/80x80/10b981/ffffff?text=최대리' },
            'dummyUser4': { name: '박부장', company: 'Startup Tech', description: '기술 컨설팅 및 솔루션 아키텍처 담당입니다.', profileImageUrl: 'https://placehold.co/80x80/ef4444/ffffff?text=박부장' },
            [AI_ASSISTANT_ID]: { name: AI_ASSISTANT_NAME, company: 'Gemini AI', description: '다양한 질문에 답변하고 대화를 돕는 AI 도우미입니다.', profileImageUrl: 'https://placehold.co/80x80/8b5cf6/ffffff?text=AI' }
        };

        /**
         * Initializes Firebase and sets up the authentication listener.
         */
        async function initializeFirebase() {
            try {
                // Check if Firebase config is missing
                if (Object.keys(firebaseConfig).length === 0) {
                    console.error("Firebase config is missing. Cannot initialize Firebase.");
                } else {
                    app = initializeApp(firebaseConfig);
                    db = getFirestore(app);
                    auth = getAuth(app);
                }

                // Set up listener for authentication state changes
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid; // Set authenticated user ID
                        console.log("Firebase authenticated. User ID:", userId);
                    } else {
                        console.log("No user signed in. Attempting sign-in...");
                        try {
                            if (initialAuthToken) {
                                // Try signing in with custom token if available
                                await signInWithCustomToken(auth, initialAuthToken);
                                console.log("Signed in with custom token successfully.");
                            } else {
                                // If no custom token, try anonymous sign-in
                                await signInAnonymously(auth);
                                console.log("Signed in anonymously.");
                            }
                            userId = auth.currentUser?.uid || crypto.randomUUID(); // Fallback to random ID if UID still not available
                            console.log("Auth attempt complete. Current User ID:", userId);
                        } catch (error) {
                            // If custom token sign-in fails (e.g., auth/invalid-claims), try anonymous sign-in as fallback
                            console.log("Initial sign-in attempt (custom token) failed. Attempting anonymous sign-in as fallback...", error.message);
                            try {
                                await signInAnonymously(auth);
                                userId = auth.currentUser?.uid || crypto.randomUUID();
                                console.log("Successfully signed in anonymously as fallback. Current User ID:", userId);
                            } catch (anonError) {
                                console.error("Firebase anonymous sign-in fallback also failed:", anonError);
                                userId = crypto.randomUUID(); // Assign random ID if all auth attempts fail
                            }
                        }
                    }
                    isAuthReady = true; // Auth process completed (user or anonymous)
                    // Load dummy data or set up real data listener after Firebase init and auth are complete
                    if (db) { // Check if db was successfully initialized
                         setupFirestoreListeners(); // Set up real Firestore data listeners
                    } else {
                        // Fallback to dummy data if Firebase DB initialization fails
                        loadDummyChatRooms();
                    }
                    render(); // Initial render
                });
            } catch (error) {
                console.error("Firebase initialization failed:", error);
                // Fallback to dummy data if Firebase initialization fails
                loadDummyChatRooms();
                isAuthReady = true; // Allow UI rendering even without Firebase
                render();
            }
        }

        /**
         * Loads initial dummy chat room data. Includes dummy messages for each room.
         * This function is called when Firebase Firestore is not initialized or encounters an error.
         */
        function loadDummyChatRooms() {
            const now = new Date();
            // Ensure userId is set before creating dummy rooms that depend on it
            if (!userId) {
                userId = 'dummy-user-' + crypto.randomUUID().substring(0, 8);
            }
            state.chatRooms = [
                {
                    id: 'dummy-room-1',
                    name: '환영합니다! 👋',
                    lastMessage: '채팅 앱에 오신 것을 환영합니다.',
                    lastMessageTimestamp: { toDate: () => new Date(now.getTime() - 60 * 1000) },
                    participants: [userId, 'dummyUser2'], // Ensure current userId is a participant
                    messages: [
                        { senderId: 'dummyUser2', senderName: '이팀장', text: '안녕하세요! 문의사항이 있으시면 언제든지 물어보세요.', timestamp: { toDate: () => new Date(now.getTime() - 55 * 1000) } },
                        { senderId: userId, senderName: `사용자 ${userId.substring(0, 4)}`, text: '네, 감사합니다!', timestamp: { toDate: () => new Date(now.getTime() - 50 * 1000) } },
                        { senderId: AI_ASSISTANT_ID, senderName: AI_ASSISTANT_NAME, text: '환영합니다! 어떤 도움이 필요하신가요?', timestamp: { toDate: () => new Date(now.getTime() - 45 * 1000) } }
                    ]
                },
                {
                    id: 'dummy-room-2',
                    name: '프로젝트 논의방',
                    lastMessage: '다음 주 회의 안건에 대해 논의합시다.',
                    lastMessageTimestamp: { toDate: () => new Date(now.getTime() - 5 * 60 * 1000) },
                    participants: [userId, 'dummyUser3'], // Ensure current userId is a participant
                    messages: [
                        { senderId: 'dummyUser3', senderName: '최대리', text: '회의 자료 준비되셨나요?', timestamp: { toDate: () => new Date(now.getTime() - 4 * 60 * 1000) } },
                        { senderId: userId, senderName: `사용자 ${userId.substring(0, 4)}`, text: '네, 거의 다 됐습니다!', timestamp: { toDate: () => new Date(now.getTime() - 3 * 60 * 1000) } }
                    ]
                },
                {
                    id: 'dummy-room-3',
                    name: '자유 게시판 💬',
                    lastMessage: '오늘 점심 뭐 드셨나요?',
                    lastMessageTimestamp: { toDate: () => new Date(now.getTime() - 15 * 60 * 1000) },
                    participants: [userId, 'dummyUser4'], // Ensure current userId is a participant
                    messages: [
                        { senderId: 'dummyUser4', senderName: '박부장', text: '오늘 점심 뭐 드셨나요? 저는 비빔밥 먹었어요!', timestamp: { toDate: () => new Date(now.getTime() - 14 * 60 * 1000) } },
                        { senderId: userId, senderName: `사용자 ${userId.substring(0, 4)}`, text: '저는 김치찌개 먹었어요!', timestamp: { toDate: () => new Date(now.getTime() - 13 * 60 * 1000) } }
                    ]
                }
            ];
            console.log("Dummy chat rooms and messages loaded.");
        }


        /**
         * Cleans up all active Firestore listeners.
         */
        function cleanupFirestoreListeners() {
            state.firestoreListeners.forEach(unsubscribe => unsubscribe());
            state.firestoreListeners = [];
        }

        /**
         * Sets up real-time Firestore listeners for chat rooms and messages.
         */
        function setupFirestoreListeners() {
            if (!isAuthReady || !db) {
                console.log("Firestore not ready or user not authenticated. Using dummy data fallback.");
                loadDummyChatRooms(); // Load dummy data if Firestore connection fails
                return;
            }

            cleanupFirestoreListeners(); // Unsubscribe existing listeners first

            // Set up listener for chat rooms collection
            const roomsCollectionRef = collection(db, `artifacts/${appId}/public/data/chatRooms`);
            const unsubscribeRooms = onSnapshot(roomsCollectionRef, (snapshot) => {
                const rooms = [];
                snapshot.forEach(doc => {
                    rooms.push({ id: doc.id, ...doc.data() });
                });
                // Sort by last message timestamp (newest first)
                state.chatRooms = rooms.sort((a, b) => (b.lastMessageTimestamp?.toDate() || 0) - (a.lastMessageTimestamp?.toDate() || 0));
                console.log("Chat rooms updated:", state.chatRooms);
                // Only re-render chat rooms view if currently on that view
                if (state.currentView === 'chatRooms') {
                    renderChatRoomsView(document.getElementById('dynamic-content'));
                }
            }, (error) => {
                console.error("Error fetching chat rooms:", error);
                loadDummyChatRooms(); // Fallback to dummy data on error
            });
            state.firestoreListeners.push(unsubscribeRooms);

            // Set up listener for messages in the selected chat room (if in messages view)
            if (state.currentView === 'chatMessages' && state.selectedRoomId) {
                const messagesCollectionRef = collection(db, `artifacts/${appId}/public/data/chatRooms/${state.selectedRoomId}/messages`);
                // Note: Firestore orderBy requires an index; sorting in-memory here for simplicity.
                const unsubscribeMessages = onSnapshot(messagesCollectionRef, (snapshot) => {
                    const messages = [];
                    snapshot.forEach(doc => {
                        messages.push({ id: doc.id, ...doc.data() });
                    });
                    // Sort by timestamp (oldest first)
                    state.messages = messages.sort((a, b) => (a.timestamp?.toDate() || 0) - (b.timestamp?.toDate() || 0));
                    console.log(`Messages for room ${state.selectedRoomId} updated:`, state.messages);
                    // Only update the messages content, not the whole view
                    renderMessagesContent();
                    scrollToBottom(); // Scroll to the latest message
                }, (error) => {
                    console.error("Error fetching messages:", error);
                });
                state.firestoreListeners.push(unsubscribeMessages);
            }
        }

        /**
         * Scrolls the chat message area to the bottom.
         */
        function scrollToBottom() {
            const chatMessages = document.getElementById('chat-messages');
            if (chatMessages) {
                // Use setTimeout to ensure scroll happens after DOM updates
                setTimeout(() => {
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                }, 0);
            }
        }

        /**
         * Creates a new chat room.
         * @param {string} roomName - The name of the chat room to create
         */
        async function createNewChatRoom(roomName) {
            // If in dummy mode, do not use Firestore
            if (!db) {
                console.warn("Firestore not available. Creating dummy chat room locally.");
                const newRoomId = 'dummy-room-' + Math.random().toString(36).substring(2, 9);
                const now = new Date();
                const newDummyRoom = {
                    id: newRoomId,
                    name: roomName,
                    lastMessage: "새 채팅방이 생성되었습니다.",
                    lastMessageTimestamp: { toDate: () => now },
                    participants: [userId, 'dummyUser2'], // Assume a dummy opponent
                    messages: [ // Add an initial dummy message
                        { senderId: AI_ASSISTANT_ID, senderName: AI_ASSISTANT_NAME, text: `"${roomName}" 채팅방이 개설되었습니다!`, timestamp: { toDate: () => now } }
                    ]
                };
                state.chatRooms.unshift(newDummyRoom); // Add to the beginning of the list
                setState({ currentView: 'chatMessages', selectedRoomId: newRoomId });
                return;
            }

            if (!userId) {
                console.error("Firebase DB not initialized or user not authenticated.");
                SR_showModal("오류", "채팅방을 생성할 수 없습니다. 사용자 인증 또는 데이터베이스 초기화를 확인해주세요.");
                return;
            }
            try {
                const roomsCollectionRef = collection(db, `artifacts/${appId}/public/data/chatRooms`);
                const newRoomRef = await addDoc(roomsCollectionRef, {
                    name: roomName,
                    createdAt: serverTimestamp(),
                    lastMessage: "채팅방이 생성되었습니다.",
                    lastMessageTimestamp: serverTimestamp(),
                    participants: [userId] // Add creator as participant
                });
                // Add initial message to the new room
                await addDoc(collection(db, `artifacts/${appId}/public/data/chatRooms/${newRoomRef.id}/messages`), {
                    senderId: AI_ASSISTANT_ID,
                    senderName: AI_ASSISTANT_NAME,
                    text: `"${roomName}" 채팅방이 개설되었습니다!`,
                    timestamp: serverTimestamp()
                });

                console.log("New chat room created with ID:", newRoomRef.id);
                // Navigate to the new chat room immediately after creation
                setState({
                    currentView: 'chatMessages',
                    selectedRoomId: newRoomRef.id
                });
            } catch (error) {
                console.error("Error creating new chat room:", error);
                SR_showModal("채팅방 생성 실패", "새 채팅방을 만드는 데 오류가 발생했습니다: " + error.message);
            }
        }

        /**
         * Sends a message to the currently selected chat room.
         * @param {string} messageText - The content of the message to send
         * @param {string} senderId - The ID of the message sender
         * @param {string} senderName - The name of the message sender
         */
        async function sendMessage(messageText, senderId, senderName) {
            console.log("sendMessage called with text:", messageText); // Debug log
            if (!state.selectedRoomId || !messageText.trim()) {
                console.error("Cannot send message: no room selected, or empty message.");
                return;
            }

            // Create a temporary message object for optimistic update
            const tempMessage = {
                id: 'temp-msg-' + Date.now() + Math.random().toString(36).substring(2, 9), // Unique temporary ID
                senderId: senderId,
                senderName: senderName,
                text: messageText,
                timestamp: { toDate: () => new Date() }, // Client-side timestamp
                isSending: true // Flag for optimistic rendering (optional, but good practice)
            };

            // Add the temporary message to the state and re-render only messages content
            state.messages.push(tempMessage);
            renderMessagesContent(); // Update UI
            scrollToBottom();

            // If in dummy mode, do not use Firestore after optimistic update
            if (!db) {
                console.warn("Firestore not available. Sent dummy message locally (optimistic update).");
                return;
            }

            if (!senderId) { // userId is set in initializeFirebase
                console.error("Cannot send message: sender not identified.");
                return;
            }

            try {
                const messagesCollectionRef = collection(db, `artifacts/${appId}/public/data/chatRooms/${state.selectedRoomId}/messages`);
                const docRef = await addDoc(messagesCollectionRef, {
                    senderId: senderId,
                    senderName: senderName,
                    text: messageText,
                    timestamp: serverTimestamp()
                });

                // Update last message info in the chat room document (includes AI messages)
                const roomDocRef = doc(db, `artifacts/${appId}/public/data/chatRooms/${state.selectedRoomId}`);
                await updateDoc(roomDocRef, {
                    lastMessage: messageText,
                    lastMessageTimestamp: serverTimestamp()
                });
                console.log("Message sent and room updated (Firestore confirmed).");
            } catch (error) {
                console.error("Error sending message:", error);
                SR_showModal("메시지 전송 실패", "메시지를 보내는 데 오류가 발생했습니다: " + error.message);
                // If send fails, remove the optimistically added message or mark as failed
                const index = state.messages.findIndex(msg => msg.id === tempMessage.id);
                if (index !== -1) {
                    state.messages.splice(index, 1); // Remove it
                    renderMessagesContent(); // Re-render to show removal
                }
            } finally {
                // Clear input and focus regardless of success/failure
                const messageInput = document.getElementById('message-input');
                if (messageInput) {
                    console.log("Before clearing input. Current value:", messageInput.value);
                    messageInput.value = ''; // Clear the input field immediately
                    console.log("After clearing input. Current value:", messageInput.value);
                    messageInput.focus(); // Focus immediately
                    console.log("Message input focused immediately.");
                } else {
                    console.log("Message input element not found in finally block.");
                }
                const replySuggestionsContainer = document.getElementById('reply-suggestions');
                if (replySuggestionsContainer) {
                    replySuggestionsContainer.innerHTML = ''; // Hide suggestions after sending
                }
            }
        }

        /**
         * Calls the Gemini LLM API.
         * @param {string} prompt - The prompt to send to the LLM
         * @returns {Promise<string>} - The LLM's response text
         */
        async function callGeminiAPI(prompt) {
            if (!db) { // Restrict AI features in dummy mode
                SR_showModal("AI 도우미", "죄송합니다. 현재 오프라인 모드에서는 AI 도우미 기능을 사용할 수 없습니다.");
                return "현재 AI 도우미 기능을 사용할 수 없습니다.";
            }

            let chatHistory = [];
            chatHistory.push({ role: "user", parts: [{ text: prompt }] });
            const payload = { contents: chatHistory };
            const apiKey = ""; // Automatically provided by Canvas environment
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    return result.candidates[0].content.parts[0].text;
                } else {
                    console.error("Gemini API returned an unexpected structure:", result);
                    throw new Error("Gemini API 응답 구조가 예상과 다릅니다.");
                }
            } catch (error) {
                console.error("Error calling Gemini API:", error);
                throw new Error("Gemini API 호출 중 오류 발생: " + error.message);
            }
        }

        /**
         * Asks a question to the Gemini AI Assistant and adds the response to the chat.
         */
        async function askAIAssistant() {
            if (!db) { // Restrict AI features in dummy mode
                SR_showModal("AI 도우미", "죄송합니다. 현재 오프라인 모드에서는 AI 도우미 기능을 사용할 수 없습니다.");
                return;
            }

            const question = await new Promise(resolve => {
                // Use custom input modal to get the question
                SR_showModal('AI 도우미에게 질문하기', '무엇을 도와드릴까요?', true);
                const confirmButton = document.getElementById('modal-confirm-button');
                const cancelButton = document.getElementById('modal-cancel-button');
                const inputField = document.getElementById('modal-input');

                const handleConfirm = () => {
                    const value = inputField.value.trim();
                    document.getElementById('custom-input-modal-container').remove();
                    resolve(value);
                };

                const handleCancel = () => {
                    document.getElementById('custom-input-modal-container').remove();
                    resolve(null); // Return null on cancel
                };

                confirmButton.onclick = handleConfirm;
                cancelButton.onclick = handleCancel;
                inputField.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        handleConfirm();
                    }
                });
            });

            if (!question) {
                console.log("AI Assistant question cancelled.");
                return;
            }

            // Add user's question to chat first
            await sendMessage(question, userId, `사용자 ${userId.substring(0, 4)}`);

            // Add AI response loading message to chat
            const loadingMessageRef = await addDoc(collection(db, `artifacts/${appId}/public/data/chatRooms/${state.selectedRoomId}/messages`), {
                senderId: AI_ASSISTANT_ID,
                senderName: AI_ASSISTANT_NAME,
                text: "AI 응답 생성 중...",
                timestamp: serverTimestamp(),
                isPending: true // Flag to indicate loading state
            });

            try {
                const aiResponse = await callGeminiAPI(question);
                // Update loading message with AI response
                await updateDoc(loadingMessageRef, {
                    text: aiResponse,
                    isPending: false // Loading complete
                });
                console.log("AI Assistant responded:", aiResponse);
            } catch (error) {
                console.error("AI Assistant error:", error);
                // Update loading message with error message
                await updateDoc(loadingMessageRef, {
                    text: "AI 도우미 응답 실패: " + error.message,
                    isPending: false
                });
            }
        }

        /**
         * Generates smart reply suggestions based on recent messages in the current chat room.
         */
        async function suggestSmartReplies() {
            if (state.messages.length === 0) {
                SR_showModal("답장 제안", "답장을 제안할 대화 내용이 없습니다.");
                return;
            }
            if (!db) { // Restrict AI features in dummy mode
                SR_showModal("AI 도우미", "죄송합니다. 현재 오프라인 모드에서는 답장 제안 기능을 사용할 수 없습니다.");
                return;
            }

            // Get only the last 5 messages for the summary prompt
            const recentMessages = state.messages.slice(-5);
            let conversationText = "다음 채팅 대화에 대해 3가지 짧고 정중하며 관련성 있는 답장을 제안해 주세요. 답변에는 제안된 답장만 포함하고, 각 답장은 새 줄로 구분해주세요. (예: 네, 알겠습니다.\\n다른 의견 있으신가요?\\n수고하세요.):\n\n";
            recentMessages.forEach(msg => {
                const timestamp = msg.timestamp ? new Date(msg.timestamp.toDate()).toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit' }) : '';
                conversationText += `[${timestamp}] ${msg.senderName}: ${msg.text}\n`;
            });

            const replySuggestionsContainer = document.getElementById('reply-suggestions');
            if (replySuggestionsContainer) {
                replySuggestionsContainer.innerHTML = `<span class="SR_text-secondary SR_small">답장 제안 생성 중...</span>`;
            }

            try {
                const rawSuggestions = await callGeminiAPI(conversationText);
                const suggestions = rawSuggestions.split('\n').filter(s => s.trim() !== '').slice(0, 3); // Use max 3 suggestions

                if (replySuggestionsContainer) {
                    replySuggestionsContainer.innerHTML = ''; // Clear existing loading message
                    if (suggestions.length > 0) {
                        suggestions.forEach(s => {
                            const suggestionSpan = document.createElement('span');
                            suggestionSpan.className = 'bg-[#e0eaf5] text-[#264790] SR_small SR_px-3 SR_py-1 SR_rounded-pill SR_cursor-pointer hover:bg-[#cce0f0] SR_transition-colors SR_whitespace-nowrap SR_shadow-sm';
                            suggestionSpan.textContent = s.trim();
                            suggestionSpan.onclick = () => {
                                const messageInput = document.getElementById('message-input');
                                if (messageInput) {
                                    messageInput.value = s.trim();
                                    messageInput.focus(); // Keep focus after inserting suggestion
                                }
                                replySuggestionsContainer.innerHTML = ''; // Hide suggestions after selection
                            };
                            replySuggestionsContainer.appendChild(suggestionSpan);
                        });
                    } else {
                        replySuggestionsContainer.innerHTML = `<span class="SR_text-secondary SR_small">제안된 답장이 없습니다.</span>`;
                    }
                }
            } catch (error) {
                console.error("Failed to suggest replies:", error);
                if (replySuggestionsContainer) {
                    replySuggestionsContainer.innerHTML = `<span class="SR_text-danger SR_small">답장 제안 실패: ${error.message}</span>`;
                }
            }
        }


        /**
         * Displays a custom modal message.
         * @param {string} title - Modal title
         * @param {string} message - Modal message content (can be HTML string)
         * @param {boolean} withInput - Whether to include an input field (default: false)
         * @returns {Promise<string|null>} - The input value or null (for input modals)
         */
        function SR_showModal(title, message, withInput = false) {
            return new Promise(resolve => {
                const modalContainerId = withInput ? 'custom-input-modal-container' : 'modal-container';
                const existingModal = document.getElementById(modalContainerId);
                if (existingModal) existingModal.remove(); // Remove any previously open modal

                const body = document.body;
                const div = document.createElement('div');
                div.id = modalContainerId;
                div.className = 'SR_position-fixed SR_top-0 SR_start-0 SR_w-100 SR_h-100 SR_bg-dark SR_bg-opacity-50 SR_d-flex SR_align-items-center SR_justify-content-center SR_z-index-2000';

                let inputHtml = '';
                if (withInput) {
                    inputHtml = `<input type="text" id="modal-input" placeholder="여기에 입력하세요" class="SR_form-control SR_mb-4 SR_text-dark" style="border-color: #264790;">`;
                }

                div.innerHTML = `
                    <div class="SR_bg-white SR_p-4 SR_rounded-3 SR_shadow-lg SR_w-100" style="max-width: 360px;">
                        <h3 class="SR_fs-5 SR_fw-semibold SR_text-dark SR_mb-3">${title}</h3>
                        <div class="SR_text-secondary SR_mb-3">${message}</div>
                        ${inputHtml}
                        <div class="SR_d-flex SR_justify-content-end">
                            ${withInput ? `<button id="modal-cancel-button" class="SR_btn SR_btn-secondary SR_me-2 SR_rounded-2">취소</button>` : ''}
                            <button id="modal-confirm-button" class="SR_btn SR_text-white SR_rounded-2" style="background-color: #264790;">확인</button>
                        </div>
                    </div>
                `;
                body.appendChild(div);

                const confirmButton = document.getElementById('modal-confirm-button');
                const cancelButton = document.getElementById('modal-cancel-button');
                const inputField = document.getElementById('modal-input');

                confirmButton.onclick = () => {
                    const value = withInput ? inputField.value.trim() : null;
                    if (withInput && !value) {
                         inputField.placeholder = "내용을 입력해야 합니다!";
                         inputField.classList.add('SR_is-invalid');
                         inputField.focus();
                         return;
                    }
                    div.remove();
                    resolve(value);
                };

                if (cancelButton) {
                    cancelButton.onclick = () => {
                        div.remove();
                        resolve(null);
                    };
                }

                if (inputField) {
                    inputField.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            confirmButton.click(); // Click confirm button on Enter key press
                        }
                    });
                }
            });
        }

        /**
         * Updates the global state and triggers UI re-rendering.
         * @param {object} newState - The new state object to merge
         */
        function setState(newState) {
            const prevState = { ...state }; // Capture previous state for comparison
            Object.assign(state, newState); // Merge new state into current state

            // Only re-render the whole window if major view changes or chat open/close
            if (newState.isChatOpen !== prevState.isChatOpen || newState.isMaximized !== prevState.isMaximized) {
                renderChatWindow(); // Full re-render if chat open/close or maximization changes
            }

            // Update dynamic content and element visibility based on currentView
            const dynamicContentArea = document.getElementById('dynamic-content');
            const chatHeaderTitle = document.getElementById('chat-header-title');
            const backButton = document.getElementById('back-button');
            const messageInputBar = document.getElementById('message-input-bar');
            const bottomNavBar = document.getElementById('bottom-nav-bar');

            // Handle header title and back button visibility
            if (state.currentView === 'chatMessages' || state.currentView === 'opponentProfile') {
                if (backButton) backButton.style.display = 'block';
                chatHeaderTitle.textContent = state.currentView === 'chatMessages' ? (state.chatRooms.find(r => r.id === state.selectedRoomId)?.name || '채팅방') : '프로필 정보';
            } else {
                if (backButton) backButton.style.display = 'none';
                chatHeaderTitle.textContent = state.currentView === 'home' ? '홈' : '대화';
            }

            // Handle message input bar and bottom nav bar visibility
            if (state.currentView === 'chatMessages') {
                if (messageInputBar) messageInputBar.style.display = 'flex';
                if (bottomNavBar) bottomNavBar.style.display = 'none';
                // Immediately focus the input when entering a chat room
                const messageInput = document.getElementById('message-input');
                if (messageInput) {
                    setTimeout(() => messageInput.focus(), 0);
                }
            } else {
                if (messageInputBar) messageInputBar.style.display = 'none';
                if (bottomNavBar) bottomNavBar.style.display = 'flex';
            }

            // Render dynamic content
            if (state.currentView === 'home') {
                renderHomeView(dynamicContentArea);
            } else if (state.currentView === 'chatRooms') {
                renderChatRoomsView(dynamicContentArea);
            } else if (state.currentView === 'chatMessages') {
                renderMessagesContent(); // Only render messages content here
            } else if (state.currentView === 'opponentProfile') {
                renderOpponentProfileView(dynamicContentArea);
            }

            // Re-setup listeners based on new state, only if Firebase is ready and DB is initialized
            if (isAuthReady && db) {
                setupFirestoreListeners();
            }
        }

        /**
         * Renders the floating chat button.
         */
        function renderChatButton() {
            const container = document.getElementById('chat-float-button-container');
            container.innerHTML = `
                <button id="toggle-chat-button" class="SR_btn SR_text-white SR_rounded-circle SR_d-flex SR_align-items-center SR_justify-content-center SR_shadow-lg transition-all duration-300 ease-in-out transform hover:scale-105" style="width: 56px; height: 56px; background-color: #264790;">
                    <svg style="width: 28px; height: 28px;" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 10h.01M12 10h.01M16 10h.01M9 16H5a2 2 0 00-2-2V6a2 2 0 002-2h14a2 2 0 002 2v8a2 2 0 00-2 2h-5l-5 5v-5z"></path>
                    </svg>
                </button>
            `;
            document.getElementById('toggle-chat-button').onclick = () => setState({ isChatOpen: !state.isChatOpen });
        }

        /**
         * Renders the main chat window.
         * This function now renders the static shell of the chat window.
         * Dynamic content and bar visibility are handled in setState.
         */
        function renderChatWindow() {
            const container = document.getElementById('chat-window-container');
            if (!state.isChatOpen) {
                container.innerHTML = '';
                cleanupFirestoreListeners(); // Unsubscribe listeners when chat is closed
                return;
            }

            // Show loading message if Firebase is not ready (or dummy data is being prepared)
            if (!isAuthReady) {
                container.innerHTML = `
                    <div class="SR_chat-window SR_bg-white SR_shadow-xl SR_d-flex SR_flex-column">
                        <div class="SR_d-flex SR_align-items-center SR_justify-content-center SR_h-100 SR_text-secondary">
                            로딩 중...
                        </div>
                    </div>
                `;
                return;
            }

            // Set chat window class based on maximization state
            const maximizedClass = state.isMaximized ? 'SR_is-maximized' : '';

            // Render the static shell of the chat window
            container.innerHTML = `
                <div id="chat-actual-window" class="SR_chat-window SR_bg-white SR_shadow-xl SR_d-flex SR_flex-column SR_border SR_border-light ${maximizedClass}">
                    <div class="bg-gradient-to-r SR_text-white SR_p-3 SR_rounded-top SR_d-flex SR_align-items-center SR_shadow-sm" style="background: linear-gradient(to right, #1e3c64, #264790);">
                        <button id="back-button" class="SR_btn SR_btn-sm SR_text-white SR_rounded-circle hover-bg-white-opacity-20 SR_transition-colors" style="display: none;">
                            <svg style="width: 24px; height: 24px;" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path>
                            </svg>
                        </button>
                        <h2 id="chat-header-title" class="SR_fs-5 SR_fw-semibold SR_text-truncate SR_flex-grow-1 SR_text-center"></h2>
                        <div class="SR_d-flex SR_align-items-center SR_ms-auto">
                            <button id="maximize-chat-button" class="SR_btn SR_btn-sm SR_text-white SR_rounded-circle hover-bg-white-opacity-20 SR_transition-colors" title="${state.isMaximized ? '원래대로' : '전체 화면'}">
                                ${state.isMaximized ? `
                                    <svg style="width: 24px; height: 24px;" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5v-4m0 0h-4m4 0l-5-5"></path>
                                    </svg>
                                ` : `
                                    <svg style="width: 24px; height: 24px;" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m7-5h4m0 0v4m0-4l-5 5M4 16v4m0 0h4m-4 0l5-5m7 5h4m0 0v-4m0 4l-5-5"></path>
                                    </svg>
                                `}
                            </button>
                            <button id="close-chat-button" class="SR_btn SR_btn-sm SR_text-white SR_rounded-circle hover-bg-white-opacity-20 SR_transition-colors SR_ms-2">
                                <svg style="width: 24px; height: 24px;" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                                </svg>
                            </button>
                        </div>
                    </div>

                    <div id="dynamic-content" class="SR_chat-scroll-area SR_flex-grow-1 SR_p-3">
                        </div>

                    <div id="message-input-bar" class="SR_border-top SR_p-3 SR_d-flex SR_align-items-center" style="display: none;">
                        <input type="text" id="message-input" class="SR_form-control SR_form-control-sm SR_me-2 SR_py-2 SR_ps-4 SR_pe-2 SR_rounded-pill SR_flex-grow-1 SR_text-dark" placeholder="메시지를 입력하세요...">
                        <button id="send-message-button" class="SR_btn SR_bg-primary SR_rounded-circle SR_d-flex SR_align-items-center SR_justify-content-center" style="width: 40px; height: 40px; background-color: #264790;">
                            <svg style="width: 20px; height: 20px;" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3"></path>
                            </svg>
                        </button>
                    </div>

                    <div id="bottom-nav-bar" class="SR_border-top SR_d-flex SR_justify-content-around SR_bg-body-tertiary" style="display: flex;">
                        <button id="nav-home" class="SR_btn SR_flex-fill SR_d-flex SR_flex-column SR_align-items-center SR_p-2 SR_nav-link SR_active">
                            <svg style="width: 24px; height: 24px;" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2 2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6"></path>
                            </svg>
                            <span class="SR_small SR_fw-medium SR_mt-1">홈</span>
                        </button>
                        <button id="nav-chat-rooms" class="SR_btn SR_flex-fill SR_d-flex SR_flex-column SR_align-items-center SR_p-2 SR_nav-link">
                            <svg style="width: 24px; height: 24px;" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 10h.01M12 10h.01M16 10h.01M9 16H5a2 2 0 00-2-2V6a2 2 0 002-2h14a2 2 0 002 2v8a2 2 0 00-2 2h-5l-5 5v-5z"></path>
                            </svg>
                            <span class="SR_small SR_fw-medium SR_mt-1">대화</span>
                        </button>
                        <button id="nav-ai-assistant" class="SR_btn SR_flex-fill SR_d-flex SR_flex-column SR_align-items-center SR_p-2 SR_nav-link">
                            <svg style="width: 24px; height: 24px;" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 3v2m6-2v2M9 19v2m6-2v2M5 7h14c2.209 0 4 1.791 4 4v2c0 2.209-1.791 4-4 4H5c-2.209 0-4-1.791-4-4v-2c0-2.209 1.791-4 4-4z"></path>
                            </svg>
                            <span class="SR_small SR_fw-medium SR_mt-1">AI 도우미</span>
                        </button>
                        <button id="nav-smart-reply" class="SR_btn SR_flex-fill SR_d-flex SR_flex-column SR_align-items-center SR_p-2 SR_nav-link">
                            <svg style="width: 24px; height: 24px;" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 8h10M7 12h10M7 16h6M8 20L5 17V4a2 2 0 012-2h10a2 2 0 012 2v13l-3 3h-7z"></path>
                            </svg>
                            <span class="SR_small SR_fw-medium SR_mt-1">답장 제안</span>
                        </button>
                    </div>
                </div>
            `;
            // Add event listeners after rendering (removed for brevity in plan, but would be included in final code)
            document.getElementById('maximize-chat-button').onclick = () => setState({ isMaximized: !state.isMaximized });
            document.getElementById('close-chat-button').onclick = () => setState({ isChatOpen: false });
            document.getElementById('back-button').onclick = () => {
                if (state.currentView === 'chatMessages') {
                    setState({ currentView: 'chatRooms', selectedRoomId: null });
                } else if (state.currentView === 'opponentProfile') {
                    setState({ currentView: 'chatMessages' });
                }
            };
            document.getElementById('send-message-button').onclick = () => {
                const messageInput = document.getElementById('message-input');
                if (messageInput && messageInput.value.trim()) {
                    sendMessage(messageInput.value, userId, `사용자 ${userId.substring(0, 4)}`);
                }
            };

            // Navigation button listeners
            document.getElementById('nav-home').onclick = () => setState({ currentView: 'home' });
            document.getElementById('nav-chat-rooms').onclick = () => setState({ currentView: 'chatRooms' });
            document.getElementById('nav-ai-assistant').onclick = () => askAIAssistant();
            document.getElementById('nav-smart-reply').onclick = () => suggestSmartReplies();
        }

        /**
         * Renders the home view content.
         * @param {HTMLElement} container - The container element to render into
         */
        function renderHomeView(container) {
            if (!container) return;
            container.innerHTML = `
                <div class="SR_d-flex SR_flex-column SR_align-items-center SR_justify-content-center SR_h-100 SR_text-center">
                    <svg class="SR_text-secondary SR_mb-3" style="width: 64px; height: 64px;" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 4a2 2 0 11-4 0v1a1 1 0 001 1h3a1 1 0 001-1V4zM16 16c-1.657 0-3 1.343-3 3s1.343 3 3 3 3-1.343 3-3-1.343-3-3-3zM21 12a1 1 0 01-1 1H3a1 1 0 01-1-1V6a1 1 0 011-1h17a1 1 0 011 1v6zM11 16a2 2 0 11-4 0v1a1 1 0 001 1h3a1 1 0 001-1v-1z"></path>
                    </svg>
                    <h3 class="SR_fs-5 SR_fw-semibold SR_text-dark SR_mb-2">환영합니다!</h3>
                    <p class="SR_text-secondary SR_small">아래 탐색 메뉴를 사용하여 채팅방을 확인하거나 새로운 대화를 시작할 수 있습니다.</p>
                </div>
            `;
        }

        /**
         * Renders the chat rooms list view.
         * @param {HTMLElement} container - The container element to render into
         */
        function renderChatRoomsView(container) {
            if (!container) return;
            container.innerHTML = `
                <div class="SR_list-group SR_list-group-flush">
                    ${state.chatRooms.map(room => `
                        <a href="#" class="SR_list-group-item SR_list-group-item-action SR_d-block SR_text-decoration-none SR_text-reset SR_py-3 SR_px-4" data-room-id="${room.id}">
                            <div class="SR_d-flex SR_w-100 SR_justify-content-between">
                                <h5 class="SR_mb-1 SR_fs-6 SR_fw-semibold SR_text-dark SR_text-truncate">${room.name}</h5>
                                <small class="SR_text-muted">${room.lastMessageTimestamp ? new Date(room.lastMessageTimestamp.toDate()).toLocaleDateString('ko-KR') : ''}</small>
                            </div>
                            <p class="SR_mb-1 SR_small SR_text-secondary SR_text-truncate">${room.lastMessage}</p>
                        </a>
                    `).join('')}
                    <button id="new-chat-room-button" class="SR_btn SR_btn-info SR_text-white SR_w-100 SR_rounded-bottom SR_py-3">새 채팅방 만들기</button>
                </div>
            `;

            // Add event listeners for chat room items
            container.querySelectorAll('[data-room-id]').forEach(item => {
                item.onclick = (e) => {
                    e.preventDefault();
                    const roomId = item.dataset.roomId;
                    setState({ currentView: 'chatMessages', selectedRoomId: roomId });
                };
            });

            // Add event listener for new chat room button
            document.getElementById('new-chat-room-button').onclick = async () => {
                const roomName = await new Promise(resolve => {
                    SR_showModal('새 채팅방 만들기', '채팅방 이름을 입력하세요:', true);
                    const confirmButton = document.getElementById('modal-confirm-button');
                    const cancelButton = document.getElementById('modal-cancel-button');
                    const inputField = document.getElementById('modal-input');

                    const handleConfirm = () => {
                        const value = inputField.value.trim();
                        document.getElementById('custom-input-modal-container').remove();
                        resolve(value);
                    };
                    const handleCancel = () => {
                        document.getElementById('custom-input-modal-container').remove();
                        resolve(null);
                    };
                    confirmButton.onclick = handleConfirm;
                    cancelButton.onclick = handleCancel;
                    inputField.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            handleConfirm();
                        }
                    });
                });
                if (roomName) {
                    createNewChatRoom(roomName);
                }
            };
        }

        /**
         * Renders the messages content for the current chat room.
         * This function should be called when `state.messages` changes.
         */
        function renderMessagesContent() {
            const container = document.getElementById('dynamic-content');
            if (!container) return;

            const currentRoom = state.chatRooms.find(r => r.id === state.selectedRoomId);
            const messagesToDisplay = state.messages.length > 0 ? state.messages : (currentRoom ? currentRoom.messages : []);

            container.innerHTML = `
                <div id="chat-messages" class="SR_chat-scroll-area SR_flex-grow-1">
                    ${messagesToDisplay.map(msg => {
                        const isSender = msg.senderId === userId;
                        const isAI = msg.senderId === AI_ASSISTANT_ID;
                        const messageClass = isSender ? 'SR_text-white SR_bg-primary SR_rounded-bottom SR_rounded-start SR_me-auto' :
                                       (isAI ? 'SR_bg-light SR_text-dark SR_rounded-bottom SR_rounded-end SR_ms-auto' :
                                               'SR_bg-light SR_text-dark SR_rounded-bottom SR_rounded-end SR_ms-auto');
                        const alignmentClass = isSender ? 'SR_text-end' : 'SR_text-start';
                        const avatarSrc = dummyUserProfiles[msg.senderId]?.profileImageUrl || (isSender ? `https://placehold.co/80x80/6366f1/ffffff?text=${msg.senderName.substring(0, 2)}` : `https://placehold.co/80x80/6c757d/ffffff?text=${msg.senderName.substring(0, 2)}`);

                        return `
                            <div class="SR_d-flex ${alignmentClass} SR_mb-2">
                                ${!isSender ? `
                                    <img src="${avatarSrc}" alt="${msg.senderName}" class="SR_rounded-circle SR_me-2" style="width: 32px; height: 32px;">
                                ` : ''}
                                <div class="SR_d-flex SR_flex-column">
                                    <div class="SR_small SR_text-muted ${isSender ? 'SR_text-end' : 'SR_text-start'}">${msg.senderName}</div>
                                    <div class="SR_px-3 SR_py-2 SR_rounded-3 SR_text-wrap ${messageClass}" style="max-width: 80%;">
                                        ${msg.text}
                                        ${msg.isPending ? ` <span class="SR_small SR_text-muted">(전송 중...)</span>` : ''}
                                    </div>
                                    <div class="SR_small SR_text-muted SR_mt-1 ${isSender ? 'SR_text-end' : 'SR_text-start'}">
                                        ${msg.timestamp ? new Date(msg.timestamp.toDate()).toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit' }) : ''}
                                    </div>
                                </div>
                                ${isSender ? `
                                    <img src="${avatarSrc}" alt="${msg.senderName}" class="SR_rounded-circle SR_ms-2" style="width: 32px; height: 32px;">
                                ` : ''}
                            </div>
                        `;
                    }).join('')}
                </div>
                <div id="reply-suggestions" class="SR_d-flex SR_flex-wrap gap-2 SR_mt-3 SR_mb-2 SR_px-3"></div>
            `;
            scrollToBottom();
        }

        /**
         * Renders the opponent's profile view.
         * @param {HTMLElement} container - The container element to render into
         */
        function renderOpponentProfileView(container) {
            if (!container) return;

            const opponentId = state.selectedOpponentId;
            const opponentProfile = dummyUserProfiles[opponentId];

            if (!opponentProfile) {
                container.innerHTML = `<div class="SR_text-center SR_text-secondary SR_py-5">프로필 정보를 찾을 수 없습니다.</div>`;
                return;
            }

            container.innerHTML = `
                <div class="SR_d-flex SR_flex-column SR_align-items-center SR_p-4">
                    <img src="${opponentProfile.profileImageUrl}" alt="${opponentProfile.name}" class="SR_rounded-circle SR_mb-3 SR_shadow-sm" style="width: 96px; height: 96px;">
                    <h3 class="SR_fs-5 SR_fw-semibold SR_text-dark SR_mb-1">${opponentProfile.name}</h3>
                    <p class="SR_text-secondary SR_small SR_mb-3">${opponentProfile.company}</p>
                    <p class="SR_text-dark SR_text-center SR_px-3">${opponentProfile.description}</p>

                    <h4 class="SR_fs-6 SR_fw-semibold SR_text-dark SR_mt-4 SR_mb-3">포트폴리오</h4>
                    <div id="opponent-portfolio-carousel-container" class="SR_w-100 SR_position-relative">
                        <div id="opponent-portfolio-carousel" class="SR_d-flex SR_overflow-auto SR_hide-scrollbar" style="scroll-snap-type: x mandatory;">
                            ${dummyPortfolios.map(p => `
                                <div class="SR_mx-2 SR_p-2 SR_card SR_shadow-sm" style="min-width: 180px; scroll-snap-align: start;">
                                    <img src="${p.imageUrl}" class="SR_card-img-top SR_rounded SR_mb-2" alt="${p.title}">
                                    <div class="SR_card-body SR_p-0">
                                        <h5 class="SR_fs-6 SR_fw-semibold SR_text-truncate SR_mb-1">${p.title}</h5>
                                        <p class="SR_text-muted SR_small">${p.description.substring(0, 50)}...</p>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                        <button id="opponent-portfolio-scroll-left" class="SR_btn SR_btn-sm SR_rounded-circle SR_position-absolute SR_top-50 SR_start-0 translate-middle-y SR_shadow-lg" style="background-color: rgba(255,255,255,0.8); display: none;">&lt;</button>
                        <button id="opponent-portfolio-scroll-right" class="SR_btn SR_btn-sm SR_rounded-circle SR_position-absolute SR_top-50 SR_end-0 translate-middle-y SR_shadow-lg" style="background-color: rgba(255,255,255,0.8); display: none;">&gt;</button>
                    </div>

                    <h4 class="SR_fs-6 SR_fw-semibold SR_text-dark SR_mt-4 SR_mb-3">외주 프로젝트</h4>
                    <div id="opponent-outsourcing-carousel-container" class="SR_w-100 SR_position-relative">
                        <div id="opponent-outsourcing-carousel" class="SR_d-flex SR_overflow-auto SR_hide-scrollbar" style="scroll-snap-type: x mandatory;">
                            ${dummyOutsourcings.map(o => `
                                <div class="SR_mx-2 SR_p-2 SR_card SR_shadow-sm" style="min-width: 180px; scroll-snap-align: start;">
                                    <div class="SR_card-body SR_p-0">
                                        <h5 class="SR_fs-6 SR_fw-semibold SR_text-truncate SR_mb-1">${o.title}</h5>
                                        <p class="SR_small SR_text-muted SR_mb-2">${o.description.substring(0, 50)}...</p>
                                        ${o.status === '진행 중' ? `<span class="badge SR_bg-info SR_text-dark">진행 중</span>` :
                                          o.status === '대기 중' ? `<span class="badge SR_bg-warning SR_text-dark">대기 중</span>` :
                                          o.status === '완료' ? `<span class="badge SR_bg-success SR_text-white">완료</span>` : ''}
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                        <button id="opponent-outsourcing-scroll-left" class="SR_btn SR_btn-sm SR_rounded-circle SR_position-absolute SR_top-50 SR_start-0 translate-middle-y SR_shadow-lg" style="background-color: rgba(255,255,255,0.8); display: none;">&lt;</button>
                        <button id="opponent-outsourcing-scroll-right" class="SR_btn SR_btn-sm SR_rounded-circle SR_position-absolute SR_top-50 SR_end-0 translate-middle-y SR_shadow-lg" style="background-color: rgba(255,255,255,0.8); display: none;">&gt;</button>
                    </div>
                </div>
            `;

            // Setup carousel scroll buttons (basic functionality)
            const opponentPortfolioCarousel = document.getElementById('opponent-portfolio-carousel');
            const opponentOutsourcingCarousel = document.getElementById('opponent-outsourcing-carousel');

            if (opponentPortfolioCarousel) {
                document.getElementById('opponent-portfolio-scroll-left').onclick = () => {
                    opponentPortfolioCarousel.scrollBy({ left: -200, behavior: 'smooth' });
                };
                document.getElementById('opponent-portfolio-scroll-right').onclick = () => {
                    opponentPortfolioCarousel.scrollBy({ left: 200, behavior: 'smooth' });
                };
            }
            if (opponentOutsourcingCarousel) {
                document.getElementById('opponent-outsourcing-scroll-left').onclick = () => {
                    opponentOutsourcingCarousel.scrollBy({ left: -200, behavior: 'smooth' });
                };
                document.getElementById('opponent-outsourcing-scroll-right').onclick = () => {
                    opponentOutsourcingCarousel.scrollBy({ left: 200, behavior: 'smooth' });
                };
            }
        }


        // Function to render the entire app
        function render() {
            renderChatButton();
            renderChatWindow(); // This now renders the static shell and sets up initial listeners
        }


        // Start Firebase initialization and app rendering when the window loads
        window.onload = function() {
            initializeFirebase();
            render(); // Initial button render
        };
    </script>
</div>
</html>