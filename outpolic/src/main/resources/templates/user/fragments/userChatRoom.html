<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<div class="SR_bg-white SR_d-flex SR_align-items-center SR_justify-content-center SR_min-vh-100" th:fragment="userChatRoomFragment">
	<!-- ÏàòÏ†ïÏ§ë -->
    <div id="chat-float-button-container" class="SR_chat-float-button"></div>

    <div id="chat-window-container"></div>

    <div id="modal-container"></div>
    <div id="custom-input-modal-container"></div>

    <script type="module">
        // Firebase CDN Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, addDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, where, orderBy, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global state variables
        let app;
        let db;
        let auth;
        let userId = null; // User ID set after authentication
        let isAuthReady = false; // Flag to indicate Firebase auth is ready

        // Application state object
        let state = {
            isChatOpen: false, // Chat window open/closed status
            currentView: 'home', // Current view: 'home', 'chatRooms' (list) or 'chatMessages' (messages) - changed default to 'home'
            selectedRoomId: null, // Currently selected chat room ID
            selectedOpponentId: null, // New: Stores the ID of the selected opponent for profile view
            chatRooms: [], // Chat room data (filled with dummy data or real data)
            messages: [], // Messages for the current chat room
            firestoreListeners: [], // Array to store unsubscribe functions for Firestore listeners
            isMaximized: false // New state for chat window maximization
        };

        // Firebase configuration (provided by Canvas environment)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        // FIX: Corrected the ReferenceError by directly using the global __initial_auth_token
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Gemini AI Assistant unique ID (to differentiate from other user IDs)
        const AI_ASSISTANT_ID = "gemini-ai-assistant";
        const AI_ASSISTANT_NAME = "AI ÎèÑÏö∞ÎØ∏ ‚ú®";

        // Dummy Data for Portfolio and Outsourcing
        const dummyPortfolios = [
            { id: 'p1', title: 'ÏõπÏÇ¨Ïù¥Ìä∏ Í∞úÎ∞ú ÌîÑÎ°úÏ†ùÌä∏ (ÎåÄÍ∑úÎ™®)', description: 'Î∞òÏùëÌòï ÏõπÏÇ¨Ïù¥Ìä∏ Î∞è Î∞±ÏóîÎìú ÏãúÏä§ÌÖú Íµ¨Ï∂ï. ÏµúÏã† Ïõπ Í∏∞Ïà† Ïä§ÌÉùÏùÑ ÌôúÏö©ÌïòÏó¨ ÌôïÏû•ÏÑ±Í≥º ÏïàÏ†ïÏÑ±ÏùÑ Î≥¥Ïû•Ìï©ÎãàÎã§.', imageUrl: 'https://placehold.co/180x120/abc123/ffffff?text=ÏõπÏÇ¨Ïù¥Ìä∏' },
            { id: 'p2', title: 'Î™®Î∞îÏùº Ïï± UI/UX ÎîîÏûêÏù∏ (ÌòÅÏã†Ï†Å)', description: 'ÏÇ¨Ïö©Ïûê Ï§ëÏã¨Ïùò ÏßÅÍ¥ÄÏ†ÅÏù∏ Ïù∏ÌÑ∞ÌéòÏù¥Ïä§ ÏÑ§Í≥Ñ Î∞è ÎîîÏûêÏù∏ ÏãúÏä§ÌÖú Íµ¨Ï∂ïÏúºÎ°ú ÏÇ¨Ïö©Ïûê ÎßåÏ°±ÎèÑÎ•º Í∑πÎåÄÌôîÌï©ÎãàÎã§.', imageUrl: 'https://placehold.co/180x120/def456/ffffff?text=Î™®Î∞îÏùºÏï±' },
            { id: 'p3', title: 'Îç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù ÎåÄÏãúÎ≥¥Îìú (Ïã§ÏãúÍ∞Ñ)', description: 'ÎåÄÏö©Îüâ Îç∞Ïù¥ÌÑ∞Ïùò Ïã§ÏãúÍ∞Ñ ÏàòÏßë Î∞è ÏãúÍ∞ÅÌôî, Ïù∏ÏÇ¨Ïù¥Ìä∏ ÎèÑÏ∂úÏùÑ ÏúÑÌïú Í≥†Í∏â Î∂ÑÏÑù ÎåÄÏãúÎ≥¥Îìú ÏÜîÎ£®ÏÖòÏûÖÎãàÎã§.', imageUrl: 'https://placehold.co/180x120/789ghi/ffffff?text=Îç∞Ïù¥ÌÑ∞Î∂ÑÏÑù' },
            { id: 'p4', title: 'AI Í∏∞Î∞ò Ï±óÎ¥á ÏÜîÎ£®ÏÖò (ÎßûÏ∂§Ìòï)', description: 'ÏûêÏó∞Ïñ¥ Ï≤òÎ¶¨ Î∞è Î®∏Ïã†Îü¨Îãù Í∏∞Ïà†ÏùÑ ÌôúÏö©Ìïú ÏßÄÎä•Ìòï Ï±óÎ¥á Í∞úÎ∞úÎ°ú Í≥†Í∞ù ÏùëÎåÄ ÏûêÎèôÌôî Î∞è Ìö®Ïú®ÏÑ±ÏùÑ ÎÜíÏûÖÎãàÎã§.', imageUrl: 'https://placehold.co/180x120/jkl012/ffffff?text=AIÏ±óÎ¥á' },
            { id: 'p5', title: 'ÌÅ¥ÎùºÏö∞Îìú Ïù∏ÌîÑÎùº Íµ¨Ï∂ï (ÏïàÏ†ïÏÑ±)', description: 'AWS Í∏∞Î∞òÏùò Í≥†Í∞ÄÏö©ÏÑ± Î∞è ÌôïÏû• Í∞ÄÎä•Ìïú ÌÅ¥ÎùºÏö∞Îìú Ïù∏ÌîÑÎùºÎ•º ÏÑ§Í≥ÑÌïòÍ≥† Íµ¨Ï∂ïÌïòÏó¨ ÏïàÏ†ïÏ†ÅÏù∏ ÏÑúÎπÑÏä§ Ïö¥ÏòÅÏùÑ ÏßÄÏõêÌï©ÎãàÎã§.', imageUrl: 'https://placehold.co/180x120/mno345/ffffff?text=ÌÅ¥ÎùºÏö∞Îìú' },
            { id: 'p6', title: 'Í≤åÏûÑ Í∞úÎ∞ú ÌîÑÎ†àÏûÑÏõåÌÅ¨', description: 'ÌÅ¨Î°úÏä§ ÌîåÎû´Ìèº Í≤åÏûÑ Í∞úÎ∞úÏùÑ ÏúÑÌïú Í∞ïÎ†•Ìïú ÌîÑÎ†àÏûÑÏõåÌÅ¨ ÏÑ§Í≥Ñ', imageUrl: 'https://placehold.co/180x120/456def/ffffff?text=Í≤åÏûÑÍ∞úÎ∞ú' }
        ];

        const dummyOutsourcings = [
            { id: 'o1', title: 'Ïã†Í∑ú ÏÑúÎπÑÏä§ ÎûúÎî© ÌéòÏù¥ÏßÄ Ï†úÏûë', description: 'Ïã†Í∑ú ÏÑúÎπÑÏä§ Îü∞Ïπ≠ÏùÑ ÏúÑÌïú ÎßàÏºÄÌåÖÏö© Í≥†ÏÑ±Îä• ÎûúÎî© ÌéòÏù¥ÏßÄ Í∞úÎ∞úÏù¥ ÌïÑÏöîÌï©ÎãàÎã§.', status: 'ÏßÑÌñâ Ï§ë' },
            { id: 'o2', title: 'Ïû¨Í≥† Í¥ÄÎ¶¨ ÏãúÏä§ÌÖú Í∞úÎ∞ú ÏùòÎ¢∞', description: 'ÏÜåÏÉÅÍ≥µÏù∏ÏùÑ ÏúÑÌïú ÎßûÏ∂§Ìòï ÌÅ¥ÎùºÏö∞Îìú Í∏∞Î∞ò Ïû¨Í≥† Í¥ÄÎ¶¨ ÏãúÏä§ÌÖú Í∞úÎ∞úÏùÑ ÏùòÎ¢∞Ìï©ÎãàÎã§.', status: 'ÎåÄÍ∏∞ Ï§ë' },
            { id: 'o3', title: 'ERP ÏãúÏä§ÌÖú Î™®Îìà Ïó∞Îèô Î∞è Ïª§Ïä§ÌÑ∞ÎßàÏù¥Ïßï', description: 'Í∏∞Ï°¥ ERPÏóê Ïã†Í∑ú Î™®Îìà Ïó∞Îèô Î∞è Í∏∞ÏóÖ ÌäπÏÑ±Ïóê ÎßûÎäî Í∏∞Îä• Ïª§Ïä§ÌÑ∞ÎßàÏù¥Ïßï ÌîÑÎ°úÏ†ùÌä∏ÏûÖÎãàÎã§.', status: 'ÏôÑÎ£å' },
            { id: 'o4', title: 'Ïª®ÌÖêÏ∏† Í¥ÄÎ¶¨ ÏãúÏä§ÌÖú Í≥†ÎèÑÌôî Í∞úÎ∞ú', description: 'Í∏∞Ï°¥ Ïª®ÌÖêÏ∏† Í¥ÄÎ¶¨ ÏãúÏä§ÌÖúÏóê Ïù¥ÎØ∏ÏßÄ Î∞è ÎπÑÎîîÏò§ Ï≤òÎ¶¨ Í∏∞Îä• Í∞ïÌôîÎ•º ÏúÑÌïú Í≥†ÎèÑÌôî Í∞úÎ∞úÏùÑ ÏöîÏ≤≠Ìï©ÎãàÎã§.', status: 'ÏßÑÌñâ Ï§ë' },
            { id: 'o5', title: 'ÏÇ¨ÎÇ¥ ÍµêÏú° ÌîåÎû´Ìèº Íµ¨Ï∂ï', description: 'ÏßÅÏõê ÍµêÏú°ÏùÑ ÏúÑÌïú Ïù∏ÌÑ∞ÎûôÌã∞Î∏å Ïò®ÎùºÏù∏ ÍµêÏú° ÌîåÎû´Ìèº Íµ¨Ï∂ï ÌîÑÎ°úÏ†ùÌä∏ÏûÖÎãàÎã§.', status: 'ÏßÑÌñâ Ï§ë' },
            { id: 'o6', title: 'Î≥¥Ïïà ÏÜîÎ£®ÏÖò ÎèÑÏûÖ Ïª®ÏÑ§ÌåÖ', description: 'Í∏∞ÏóÖ Îç∞Ïù¥ÌÑ∞ Î≥¥Ïïà Í∞ïÌôîÎ•º ÏúÑÌïú Ï†ÑÎ¨∏Í∞Ä Ïª®ÏÑ§ÌåÖ Î∞è ÏÜîÎ£®ÏÖò ÎèÑÏûÖÏùÑ Ìù¨ÎßùÌï©ÎãàÎã§.', status: 'ÎåÄÍ∏∞ Ï§ë' }
        ];

        // Dummy Profile Data for other users (for opponent profile view)
        const dummyUserProfiles = {
            'dummyUser2': { name: 'Ïù¥ÌåÄÏû•', company: 'ABC ÏÜîÎ£®ÏÖò', description: 'ÌîÑÎ°úÏ†ùÌä∏ Í¥ÄÎ¶¨ Î∞è Í∏∞Ìöç Ï†ÑÎ¨∏Í∞ÄÏûÖÎãàÎã§.', profileImageUrl: 'https://placehold.co/80x80/6366f1/ffffff?text=Ïù¥ÌåÄÏû•' },
            'dummyUser3': { name: 'ÏµúÎåÄÎ¶¨', company: 'XYZ ÎîîÏûêÏù∏', description: 'Ï∞ΩÏùòÏ†ÅÏù∏ UI/UX ÎîîÏûêÏù∏ÏùÑ Îã¥ÎãπÌï©ÎãàÎã§.', profileImageUrl: 'https://placehold.co/80x80/10b981/ffffff?text=ÏµúÎåÄÎ¶¨' },
            'dummyUser4': { name: 'Î∞ïÎ∂ÄÏû•', company: 'Startup Tech', description: 'Í∏∞Ïà† Ïª®ÏÑ§ÌåÖ Î∞è ÏÜîÎ£®ÏÖò ÏïÑÌÇ§ÌÖçÏ≤ò Îã¥ÎãπÏûÖÎãàÎã§.', profileImageUrl: 'https://placehold.co/80x80/ef4444/ffffff?text=Î∞ïÎ∂ÄÏû•' },
            [AI_ASSISTANT_ID]: { name: AI_ASSISTANT_NAME, company: 'Gemini AI', description: 'Îã§ÏñëÌïú ÏßàÎ¨∏Ïóê ÎãµÎ≥ÄÌïòÍ≥† ÎåÄÌôîÎ•º ÎèïÎäî AI ÎèÑÏö∞ÎØ∏ÏûÖÎãàÎã§.', profileImageUrl: 'https://placehold.co/80x80/8b5cf6/ffffff?text=AI' }
        };

        /**
         * Initializes Firebase and sets up the authentication listener.
         */
        async function initializeFirebase() {
            try {
                // Check if Firebase config is missing
                if (Object.keys(firebaseConfig).length === 0) {
                    console.error("Firebase config is missing. Cannot initialize Firebase.");
                } else {
                    app = initializeApp(firebaseConfig);
                    db = getFirestore(app);
                    auth = getAuth(app);
                }

                // Set up listener for authentication state changes
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid; // Set authenticated user ID
                        console.log("Firebase authenticated. User ID:", userId);
                    } else {
                        console.log("No user signed in. Attempting sign-in...");
                        try {
                            if (initialAuthToken) {
                                // Try signing in with custom token if available
                                await signInWithCustomToken(auth, initialAuthToken);
                                console.log("Signed in with custom token successfully.");
                            } else {
                                // If no custom token, try anonymous sign-in
                                await signInAnonymously(auth);
                                console.log("Signed in anonymously.");
                            }
                            userId = auth.currentUser?.uid || crypto.randomUUID(); // Fallback to random ID if UID still not available
                            console.log("Auth attempt complete. Current User ID:", userId);
                        } catch (error) {
                            // If custom token sign-in fails (e.g., auth/invalid-claims), try anonymous sign-in as fallback
                            console.log("Initial sign-in attempt (custom token) failed. Attempting anonymous sign-in as fallback...", error.message);
                            try {
                                await signInAnonymously(auth);
                                userId = auth.currentUser?.uid || crypto.randomUUID();
                                console.log("Successfully signed in anonymously as fallback. Current User ID:", userId);
                            } catch (anonError) {
                                console.error("Firebase anonymous sign-in fallback also failed:", anonError);
                                userId = crypto.randomUUID(); // Assign random ID if all auth attempts fail
                            }
                        }
                    }
                    isAuthReady = true; // Auth process completed (user or anonymous)
                    // Load dummy data or set up real data listener after Firebase init and auth are complete
                    if (db) { // Check if db was successfully initialized
                         setupFirestoreListeners(); // Set up real Firestore data listeners
                    } else {
                        // Fallback to dummy data if Firebase DB initialization fails
                        loadDummyChatRooms();
                    }
                    render(); // Initial render
                });
            } catch (error) {
                console.error("Firebase initialization failed:", error);
                // Fallback to dummy data if Firebase initialization fails
                loadDummyChatRooms();
                isAuthReady = true; // Allow UI rendering even without Firebase
                render();
            }
        }

        /**
         * Loads initial dummy chat room data. Includes dummy messages for each room.
         * This function is called when Firebase Firestore is not initialized or encounters an error.
         */
        function loadDummyChatRooms() {
            const now = new Date();
            // Ensure userId is set before creating dummy rooms that depend on it
            if (!userId) {
                userId = 'dummy-user-' + crypto.randomUUID().substring(0, 8);
            }
            state.chatRooms = [
                {
                    id: 'dummy-room-1',
                    name: 'ÌôòÏòÅÌï©ÎãàÎã§! üëã',
                    lastMessage: 'Ï±ÑÌåÖ Ïï±Ïóê Ïò§Ïã† Í≤ÉÏùÑ ÌôòÏòÅÌï©ÎãàÎã§.',
                    lastMessageTimestamp: { toDate: () => new Date(now.getTime() - 60 * 1000) },
                    participants: [userId, 'dummyUser2'], // Ensure current userId is a participant
                    messages: [
                        { senderId: 'dummyUser2', senderName: 'Ïù¥ÌåÄÏû•', text: 'ÏïàÎÖïÌïòÏÑ∏Ïöî! Î¨∏ÏùòÏÇ¨Ìï≠Ïù¥ ÏûàÏúºÏãúÎ©¥ Ïñ∏Ï†úÎì†ÏßÄ Î¨ºÏñ¥Î≥¥ÏÑ∏Ïöî.', timestamp: { toDate: () => new Date(now.getTime() - 55 * 1000) } },
                        { senderId: userId, senderName: `ÏÇ¨Ïö©Ïûê ${userId.substring(0, 4)}`, text: 'ÎÑ§, Í∞êÏÇ¨Ìï©ÎãàÎã§!', timestamp: { toDate: () => new Date(now.getTime() - 50 * 1000) } },
                        { senderId: AI_ASSISTANT_ID, senderName: AI_ASSISTANT_NAME, text: 'ÌôòÏòÅÌï©ÎãàÎã§! Ïñ¥Îñ§ ÎèÑÏõÄÏù¥ ÌïÑÏöîÌïòÏã†Í∞ÄÏöî?', timestamp: { toDate: () => new Date(now.getTime() - 45 * 1000) } }
                    ]
                },
                {
                    id: 'dummy-room-2',
                    name: 'ÌîÑÎ°úÏ†ùÌä∏ ÎÖºÏùòÎ∞©',
                    lastMessage: 'Îã§Ïùå Ï£º ÌöåÏùò ÏïàÍ±¥Ïóê ÎåÄÌï¥ ÎÖºÏùòÌï©ÏãúÎã§.',
                    lastMessageTimestamp: { toDate: () => new Date(now.getTime() - 5 * 60 * 1000) },
                    participants: [userId, 'dummyUser3'], // Ensure current userId is a participant
                    messages: [
                        { senderId: 'dummyUser3', senderName: 'ÏµúÎåÄÎ¶¨', text: 'ÌöåÏùò ÏûêÎ£å Ï§ÄÎπÑÎêòÏÖ®ÎÇòÏöî?', timestamp: { toDate: () => new Date(now.getTime() - 4 * 60 * 1000) } },
                        { senderId: userId, senderName: `ÏÇ¨Ïö©Ïûê ${userId.substring(0, 4)}`, text: 'ÎÑ§, Í±∞Ïùò Îã§ ÎêêÏäµÎãàÎã§!', timestamp: { toDate: () => new Date(now.getTime() - 3 * 60 * 1000) } }
                    ]
                },
                {
                    id: 'dummy-room-3',
                    name: 'ÏûêÏú† Í≤åÏãúÌåê üí¨',
                    lastMessage: 'Ïò§Îäò Ï†êÏã¨ Î≠ê ÎìúÏÖ®ÎÇòÏöî?',
                    lastMessageTimestamp: { toDate: () => new Date(now.getTime() - 15 * 60 * 1000) },
                    participants: [userId, 'dummyUser4'], // Ensure current userId is a participant
                    messages: [
                        { senderId: 'dummyUser4', senderName: 'Î∞ïÎ∂ÄÏû•', text: 'Ïò§Îäò Ï†êÏã¨ Î≠ê ÎìúÏÖ®ÎÇòÏöî? Ï†ÄÎäî ÎπÑÎπîÎ∞• Î®πÏóàÏñ¥Ïöî!', timestamp: { toDate: () => new Date(now.getTime() - 14 * 60 * 1000) } },
                        { senderId: userId, senderName: `ÏÇ¨Ïö©Ïûê ${userId.substring(0, 4)}`, text: 'Ï†ÄÎäî ÍπÄÏπòÏ∞åÍ∞ú Î®πÏóàÏñ¥Ïöî!', timestamp: { toDate: () => new Date(now.getTime() - 13 * 60 * 1000) } }
                    ]
                }
            ];
            console.log("Dummy chat rooms and messages loaded.");
        }


        /**
         * Cleans up all active Firestore listeners.
         */
        function cleanupFirestoreListeners() {
            state.firestoreListeners.forEach(unsubscribe => unsubscribe());
            state.firestoreListeners = [];
        }

        /**
         * Sets up real-time Firestore listeners for chat rooms and messages.
         */
        function setupFirestoreListeners() {
            if (!isAuthReady || !db) {
                console.log("Firestore not ready or user not authenticated. Using dummy data fallback.");
                loadDummyChatRooms(); // Load dummy data if Firestore connection fails
                return;
            }

            cleanupFirestoreListeners(); // Unsubscribe existing listeners first

            // Set up listener for chat rooms collection
            const roomsCollectionRef = collection(db, `artifacts/${appId}/public/data/chatRooms`);
            const unsubscribeRooms = onSnapshot(roomsCollectionRef, (snapshot) => {
                const rooms = [];
                snapshot.forEach(doc => {
                    rooms.push({ id: doc.id, ...doc.data() });
                });
                // Sort by last message timestamp (newest first)
                state.chatRooms = rooms.sort((a, b) => (b.lastMessageTimestamp?.toDate() || 0) - (a.lastMessageTimestamp?.toDate() || 0));
                console.log("Chat rooms updated:", state.chatRooms);
                // Only re-render chat rooms view if currently on that view
                if (state.currentView === 'chatRooms') {
                    renderChatRoomsView(document.getElementById('dynamic-content'));
                }
            }, (error) => {
                console.error("Error fetching chat rooms:", error);
                loadDummyChatRooms(); // Fallback to dummy data on error
            });
            state.firestoreListeners.push(unsubscribeRooms);

            // Set up listener for messages in the selected chat room (if in messages view)
            if (state.currentView === 'chatMessages' && state.selectedRoomId) {
                const messagesCollectionRef = collection(db, `artifacts/${appId}/public/data/chatRooms/${state.selectedRoomId}/messages`);
                // Note: Firestore orderBy requires an index; sorting in-memory here for simplicity.
                const unsubscribeMessages = onSnapshot(messagesCollectionRef, (snapshot) => {
                    const messages = [];
                    snapshot.forEach(doc => {
                        messages.push({ id: doc.id, ...doc.data() });
                    });
                    // Sort by timestamp (oldest first)
                    state.messages = messages.sort((a, b) => (a.timestamp?.toDate() || 0) - (b.timestamp?.toDate() || 0));
                    console.log(`Messages for room ${state.selectedRoomId} updated:`, state.messages);
                    // Only update the messages content, not the whole view
                    renderMessagesContent();
                    scrollToBottom(); // Scroll to the latest message
                }, (error) => {
                    console.error("Error fetching messages:", error);
                });
                state.firestoreListeners.push(unsubscribeMessages);
            }
        }

        /**
         * Scrolls the chat message area to the bottom.
         */
        function scrollToBottom() {
            const chatMessages = document.getElementById('chat-messages');
            if (chatMessages) {
                // Use setTimeout to ensure scroll happens after DOM updates
                setTimeout(() => {
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                }, 0);
            }
        }

        /**
         * Creates a new chat room.
         * @param {string} roomName - The name of the chat room to create
         */
        async function createNewChatRoom(roomName) {
            // If in dummy mode, do not use Firestore
            if (!db) {
                console.warn("Firestore not available. Creating dummy chat room locally.");
                const newRoomId = 'dummy-room-' + Math.random().toString(36).substring(2, 9);
                const now = new Date();
                const newDummyRoom = {
                    id: newRoomId,
                    name: roomName,
                    lastMessage: "ÏÉà Ï±ÑÌåÖÎ∞©Ïù¥ ÏÉùÏÑ±ÎêòÏóàÏäµÎãàÎã§.",
                    lastMessageTimestamp: { toDate: () => now },
                    participants: [userId, 'dummyUser2'], // Assume a dummy opponent
                    messages: [ // Add an initial dummy message
                        { senderId: AI_ASSISTANT_ID, senderName: AI_ASSISTANT_NAME, text: `"${roomName}" Ï±ÑÌåÖÎ∞©Ïù¥ Í∞úÏÑ§ÎêòÏóàÏäµÎãàÎã§!`, timestamp: { toDate: () => now } }
                    ]
                };
                state.chatRooms.unshift(newDummyRoom); // Add to the beginning of the list
                setState({ currentView: 'chatMessages', selectedRoomId: newRoomId });
                return;
            }

            if (!userId) {
                console.error("Firebase DB not initialized or user not authenticated.");
                SR_showModal("Ïò§Î•ò", "Ï±ÑÌåÖÎ∞©ÏùÑ ÏÉùÏÑ±Ìï† Ïàò ÏóÜÏäµÎãàÎã§. ÏÇ¨Ïö©Ïûê Ïù∏Ï¶ù ÎòêÎäî Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï¥àÍ∏∞ÌôîÎ•º ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.");
                return;
            }
            try {
                const roomsCollectionRef = collection(db, `artifacts/${appId}/public/data/chatRooms`);
                const newRoomRef = await addDoc(roomsCollectionRef, {
                    name: roomName,
                    createdAt: serverTimestamp(),
                    lastMessage: "Ï±ÑÌåÖÎ∞©Ïù¥ ÏÉùÏÑ±ÎêòÏóàÏäµÎãàÎã§.",
                    lastMessageTimestamp: serverTimestamp(),
                    participants: [userId] // Add creator as participant
                });
                // Add initial message to the new room
                await addDoc(collection(db, `artifacts/${appId}/public/data/chatRooms/${newRoomRef.id}/messages`), {
                    senderId: AI_ASSISTANT_ID,
                    senderName: AI_ASSISTANT_NAME,
                    text: `"${roomName}" Ï±ÑÌåÖÎ∞©Ïù¥ Í∞úÏÑ§ÎêòÏóàÏäµÎãàÎã§!`,
                    timestamp: serverTimestamp()
                });

                console.log("New chat room created with ID:", newRoomRef.id);
                // Navigate to the new chat room immediately after creation
                setState({
                    currentView: 'chatMessages',
                    selectedRoomId: newRoomRef.id
                });
            } catch (error) {
                console.error("Error creating new chat room:", error);
                SR_showModal("Ï±ÑÌåÖÎ∞© ÏÉùÏÑ± Ïã§Ìå®", "ÏÉà Ï±ÑÌåÖÎ∞©ÏùÑ ÎßåÎìúÎäî Îç∞ Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: " + error.message);
            }
        }

        /**
         * Sends a message to the currently selected chat room.
         * @param {string} messageText - The content of the message to send
         * @param {string} senderId - The ID of the message sender
         * @param {string} senderName - The name of the message sender
         */
        async function sendMessage(messageText, senderId, senderName) {
            console.log("sendMessage called with text:", messageText); // Debug log
            if (!state.selectedRoomId || !messageText.trim()) {
                console.error("Cannot send message: no room selected, or empty message.");
                return;
            }

            // Create a temporary message object for optimistic update
            const tempMessage = {
                id: 'temp-msg-' + Date.now() + Math.random().toString(36).substring(2, 9), // Unique temporary ID
                senderId: senderId,
                senderName: senderName,
                text: messageText,
                timestamp: { toDate: () => new Date() }, // Client-side timestamp
                isSending: true // Flag for optimistic rendering (optional, but good practice)
            };

            // Add the temporary message to the state and re-render only messages content
            state.messages.push(tempMessage);
            renderMessagesContent(); // Update UI
            scrollToBottom();

            // If in dummy mode, do not use Firestore after optimistic update
            if (!db) {
                console.warn("Firestore not available. Sent dummy message locally (optimistic update).");
                return;
            }

            if (!senderId) { // userId is set in initializeFirebase
                console.error("Cannot send message: sender not identified.");
                return;
            }

            try {
                const messagesCollectionRef = collection(db, `artifacts/${appId}/public/data/chatRooms/${state.selectedRoomId}/messages`);
                const docRef = await addDoc(messagesCollectionRef, {
                    senderId: senderId,
                    senderName: senderName,
                    text: messageText,
                    timestamp: serverTimestamp()
                });

                // Update last message info in the chat room document (includes AI messages)
                const roomDocRef = doc(db, `artifacts/${appId}/public/data/chatRooms/${state.selectedRoomId}`);
                await updateDoc(roomDocRef, {
                    lastMessage: messageText,
                    lastMessageTimestamp: serverTimestamp()
                });
                console.log("Message sent and room updated (Firestore confirmed).");
            } catch (error) {
                console.error("Error sending message:", error);
                SR_showModal("Î©îÏãúÏßÄ Ï†ÑÏÜ° Ïã§Ìå®", "Î©îÏãúÏßÄÎ•º Î≥¥ÎÇ¥Îäî Îç∞ Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: " + error.message);
                // If send fails, remove the optimistically added message or mark as failed
                const index = state.messages.findIndex(msg => msg.id === tempMessage.id);
                if (index !== -1) {
                    state.messages.splice(index, 1); // Remove it
                    renderMessagesContent(); // Re-render to show removal
                }
            } finally {
                // Clear input and focus regardless of success/failure
                const messageInput = document.getElementById('message-input');
                if (messageInput) {
                    console.log("Before clearing input. Current value:", messageInput.value);
                    messageInput.value = ''; // Clear the input field immediately
                    console.log("After clearing input. Current value:", messageInput.value);
                    messageInput.focus(); // Focus immediately
                    console.log("Message input focused immediately.");
                } else {
                    console.log("Message input element not found in finally block.");
                }
                const replySuggestionsContainer = document.getElementById('reply-suggestions');
                if (replySuggestionsContainer) {
                    replySuggestionsContainer.innerHTML = ''; // Hide suggestions after sending
                }
            }
        }

        /**
         * Calls the Gemini LLM API.
         * @param {string} prompt - The prompt to send to the LLM
         * @returns {Promise<string>} - The LLM's response text
         */
        async function callGeminiAPI(prompt) {
            if (!db) { // Restrict AI features in dummy mode
                SR_showModal("AI ÎèÑÏö∞ÎØ∏", "Ï£ÑÏÜ°Ìï©ÎãàÎã§. ÌòÑÏû¨ Ïò§ÌîÑÎùºÏù∏ Î™®ÎìúÏóêÏÑúÎäî AI ÎèÑÏö∞ÎØ∏ Í∏∞Îä•ÏùÑ ÏÇ¨Ïö©Ìï† Ïàò ÏóÜÏäµÎãàÎã§.");
                return "ÌòÑÏû¨ AI ÎèÑÏö∞ÎØ∏ Í∏∞Îä•ÏùÑ ÏÇ¨Ïö©Ìï† Ïàò ÏóÜÏäµÎãàÎã§.";
            }

            let chatHistory = [];
            chatHistory.push({ role: "user", parts: [{ text: prompt }] });
            const payload = { contents: chatHistory };
            const apiKey = ""; // Automatically provided by Canvas environment
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    return result.candidates[0].content.parts[0].text;
                } else {
                    console.error("Gemini API returned an unexpected structure:", result);
                    throw new Error("Gemini API ÏùëÎãµ Íµ¨Ï°∞Í∞Ä ÏòàÏÉÅÍ≥º Îã§Î¶ÖÎãàÎã§.");
                }
            } catch (error) {
                console.error("Error calling Gemini API:", error);
                throw new Error("Gemini API Ìò∏Ï∂ú Ï§ë Ïò§Î•ò Î∞úÏÉù: " + error.message);
            }
        }

        /**
         * Asks a question to the Gemini AI Assistant and adds the response to the chat.
         */
        async function askAIAssistant() {
            if (!db) { // Restrict AI features in dummy mode
                SR_showModal("AI ÎèÑÏö∞ÎØ∏", "Ï£ÑÏÜ°Ìï©ÎãàÎã§. ÌòÑÏû¨ Ïò§ÌîÑÎùºÏù∏ Î™®ÎìúÏóêÏÑúÎäî AI ÎèÑÏö∞ÎØ∏ Í∏∞Îä•ÏùÑ ÏÇ¨Ïö©Ìï† Ïàò ÏóÜÏäµÎãàÎã§.");
                return;
            }

            const question = await new Promise(resolve => {
                // Use custom input modal to get the question
                SR_showModal('AI ÎèÑÏö∞ÎØ∏ÏóêÍ≤å ÏßàÎ¨∏ÌïòÍ∏∞', 'Î¨¥ÏóáÏùÑ ÎèÑÏôÄÎìúÎ¶¥ÍπåÏöî?', true);
                const confirmButton = document.getElementById('modal-confirm-button');
                const cancelButton = document.getElementById('modal-cancel-button');
                const inputField = document.getElementById('modal-input');

                const handleConfirm = () => {
                    const value = inputField.value.trim();
                    document.getElementById('custom-input-modal-container').remove();
                    resolve(value);
                };

                const handleCancel = () => {
                    document.getElementById('custom-input-modal-container').remove();
                    resolve(null); // Return null on cancel
                };

                confirmButton.onclick = handleConfirm;
                cancelButton.onclick = handleCancel;
                inputField.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        handleConfirm();
                    }
                });
            });

            if (!question) {
                console.log("AI Assistant question cancelled.");
                return;
            }

            // Add user's question to chat first
            await sendMessage(question, userId, `ÏÇ¨Ïö©Ïûê ${userId.substring(0, 4)}`);

            // Add AI response loading message to chat
            const loadingMessageRef = await addDoc(collection(db, `artifacts/${appId}/public/data/chatRooms/${state.selectedRoomId}/messages`), {
                senderId: AI_ASSISTANT_ID,
                senderName: AI_ASSISTANT_NAME,
                text: "AI ÏùëÎãµ ÏÉùÏÑ± Ï§ë...",
                timestamp: serverTimestamp(),
                isPending: true // Flag to indicate loading state
            });

            try {
                const aiResponse = await callGeminiAPI(question);
                // Update loading message with AI response
                await updateDoc(loadingMessageRef, {
                    text: aiResponse,
                    isPending: false // Loading complete
                });
                console.log("AI Assistant responded:", aiResponse);
            } catch (error) {
                console.error("AI Assistant error:", error);
                // Update loading message with error message
                await updateDoc(loadingMessageRef, {
                    text: "AI ÎèÑÏö∞ÎØ∏ ÏùëÎãµ Ïã§Ìå®: " + error.message,
                    isPending: false
                });
            }
        }

        /**
         * Generates smart reply suggestions based on recent messages in the current chat room.
         */
        async function suggestSmartReplies() {
            if (state.messages.length === 0) {
                SR_showModal("ÎãµÏû• Ï†úÏïà", "ÎãµÏû•ÏùÑ Ï†úÏïàÌï† ÎåÄÌôî ÎÇ¥Ïö©Ïù¥ ÏóÜÏäµÎãàÎã§.");
                return;
            }
            if (!db) { // Restrict AI features in dummy mode
                SR_showModal("AI ÎèÑÏö∞ÎØ∏", "Ï£ÑÏÜ°Ìï©ÎãàÎã§. ÌòÑÏû¨ Ïò§ÌîÑÎùºÏù∏ Î™®ÎìúÏóêÏÑúÎäî ÎãµÏû• Ï†úÏïà Í∏∞Îä•ÏùÑ ÏÇ¨Ïö©Ìï† Ïàò ÏóÜÏäµÎãàÎã§.");
                return;
            }

            // Get only the last 5 messages for the summary prompt
            const recentMessages = state.messages.slice(-5);
            let conversationText = "Îã§Ïùå Ï±ÑÌåÖ ÎåÄÌôîÏóê ÎåÄÌï¥ 3Í∞ÄÏßÄ ÏßßÍ≥† Ï†ïÏ§ëÌïòÎ©∞ Í¥ÄÎ†®ÏÑ± ÏûàÎäî ÎãµÏû•ÏùÑ Ï†úÏïàÌï¥ Ï£ºÏÑ∏Ïöî. ÎãµÎ≥ÄÏóêÎäî Ï†úÏïàÎêú ÎãµÏû•Îßå Ìè¨Ìï®ÌïòÍ≥†, Í∞Å ÎãµÏû•ÏùÄ ÏÉà Ï§ÑÎ°ú Íµ¨Î∂ÑÌï¥Ï£ºÏÑ∏Ïöî. (Ïòà: ÎÑ§, ÏïåÍ≤†ÏäµÎãàÎã§.\\nÎã§Î•∏ ÏùòÍ≤¨ ÏûàÏúºÏã†Í∞ÄÏöî?\\nÏàòÍ≥†ÌïòÏÑ∏Ïöî.):\n\n";
            recentMessages.forEach(msg => {
                const timestamp = msg.timestamp ? new Date(msg.timestamp.toDate()).toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit' }) : '';
                conversationText += `[${timestamp}] ${msg.senderName}: ${msg.text}\n`;
            });

            const replySuggestionsContainer = document.getElementById('reply-suggestions');
            if (replySuggestionsContainer) {
                replySuggestionsContainer.innerHTML = `<span class="SR_text-secondary SR_small">ÎãµÏû• Ï†úÏïà ÏÉùÏÑ± Ï§ë...</span>`;
            }

            try {
                const rawSuggestions = await callGeminiAPI(conversationText);
                const suggestions = rawSuggestions.split('\n').filter(s => s.trim() !== '').slice(0, 3); // Use max 3 suggestions

                if (replySuggestionsContainer) {
                    replySuggestionsContainer.innerHTML = ''; // Clear existing loading message
                    if (suggestions.length > 0) {
                        suggestions.forEach(s => {
                            const suggestionSpan = document.createElement('span');
                            suggestionSpan.className = 'bg-[#e0eaf5] text-[#264790] SR_small SR_px-3 SR_py-1 SR_rounded-pill SR_cursor-pointer hover:bg-[#cce0f0] SR_transition-colors SR_whitespace-nowrap SR_shadow-sm';
                            suggestionSpan.textContent = s.trim();
                            suggestionSpan.onclick = () => {
                                const messageInput = document.getElementById('message-input');
                                if (messageInput) {
                                    messageInput.value = s.trim();
                                    messageInput.focus(); // Keep focus after inserting suggestion
                                }
                                replySuggestionsContainer.innerHTML = ''; // Hide suggestions after selection
                            };
                            replySuggestionsContainer.appendChild(suggestionSpan);
                        });
                    } else {
                        replySuggestionsContainer.innerHTML = `<span class="SR_text-secondary SR_small">Ï†úÏïàÎêú ÎãµÏû•Ïù¥ ÏóÜÏäµÎãàÎã§.</span>`;
                    }
                }
            } catch (error) {
                console.error("Failed to suggest replies:", error);
                if (replySuggestionsContainer) {
                    replySuggestionsContainer.innerHTML = `<span class="SR_text-danger SR_small">ÎãµÏû• Ï†úÏïà Ïã§Ìå®: ${error.message}</span>`;
                }
            }
        }


        /**
         * Displays a custom modal message.
         * @param {string} title - Modal title
         * @param {string} message - Modal message content (can be HTML string)
         * @param {boolean} withInput - Whether to include an input field (default: false)
         * @returns {Promise<string|null>} - The input value or null (for input modals)
         */
        function SR_showModal(title, message, withInput = false) {
            return new Promise(resolve => {
                const modalContainerId = withInput ? 'custom-input-modal-container' : 'modal-container';
                const existingModal = document.getElementById(modalContainerId);
                if (existingModal) existingModal.remove(); // Remove any previously open modal

                const body = document.body;
                const div = document.createElement('div');
                div.id = modalContainerId;
                div.className = 'SR_position-fixed SR_top-0 SR_start-0 SR_w-100 SR_h-100 SR_bg-dark SR_bg-opacity-50 SR_d-flex SR_align-items-center SR_justify-content-center SR_z-index-2000';

                let inputHtml = '';
                if (withInput) {
                    inputHtml = `<input type="text" id="modal-input" placeholder="Ïó¨Í∏∞Ïóê ÏûÖÎ†•ÌïòÏÑ∏Ïöî" class="SR_form-control SR_mb-4 SR_text-dark" style="border-color: #264790;">`;
                }

                div.innerHTML = `
                    <div class="SR_bg-white SR_p-4 SR_rounded-3 SR_shadow-lg SR_w-100" style="max-width: 360px;">
                        <h3 class="SR_fs-5 SR_fw-semibold SR_text-dark SR_mb-3">${title}</h3>
                        <div class="SR_text-secondary SR_mb-3">${message}</div>
                        ${inputHtml}
                        <div class="SR_d-flex SR_justify-content-end">
                            ${withInput ? `<button id="modal-cancel-button" class="SR_btn SR_btn-secondary SR_me-2 SR_rounded-2">Ï∑®ÏÜå</button>` : ''}
                            <button id="modal-confirm-button" class="SR_btn SR_text-white SR_rounded-2" style="background-color: #264790;">ÌôïÏù∏</button>
                        </div>
                    </div>
                `;
                body.appendChild(div);

                const confirmButton = document.getElementById('modal-confirm-button');
                const cancelButton = document.getElementById('modal-cancel-button');
                const inputField = document.getElementById('modal-input');

                confirmButton.onclick = () => {
                    const value = withInput ? inputField.value.trim() : null;
                    if (withInput && !value) {
                         inputField.placeholder = "ÎÇ¥Ïö©ÏùÑ ÏûÖÎ†•Ìï¥Ïïº Ìï©ÎãàÎã§!";
                         inputField.classList.add('SR_is-invalid');
                         inputField.focus();
                         return;
                    }
                    div.remove();
                    resolve(value);
                };

                if (cancelButton) {
                    cancelButton.onclick = () => {
                        div.remove();
                        resolve(null);
                    };
                }

                if (inputField) {
                    inputField.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            confirmButton.click(); // Click confirm button on Enter key press
                        }
                    });
                }
            });
        }

        /**
         * Updates the global state and triggers UI re-rendering.
         * @param {object} newState - The new state object to merge
         */
        function setState(newState) {
            const prevState = { ...state }; // Capture previous state for comparison
            Object.assign(state, newState); // Merge new state into current state

            // Only re-render the whole window if major view changes or chat open/close
            if (newState.isChatOpen !== prevState.isChatOpen || newState.isMaximized !== prevState.isMaximized) {
                renderChatWindow(); // Full re-render if chat open/close or maximization changes
            }

            // Update dynamic content and element visibility based on currentView
            const dynamicContentArea = document.getElementById('dynamic-content');
            const chatHeaderTitle = document.getElementById('chat-header-title');
            const backButton = document.getElementById('back-button');
            const messageInputBar = document.getElementById('message-input-bar');
            const bottomNavBar = document.getElementById('bottom-nav-bar');

            // Handle header title and back button visibility
            if (state.currentView === 'chatMessages' || state.currentView === 'opponentProfile') {
                if (backButton) backButton.style.display = 'block';
                chatHeaderTitle.textContent = state.currentView === 'chatMessages' ? (state.chatRooms.find(r => r.id === state.selectedRoomId)?.name || 'Ï±ÑÌåÖÎ∞©') : 'ÌîÑÎ°úÌïÑ Ï†ïÎ≥¥';
            } else {
                if (backButton) backButton.style.display = 'none';
                chatHeaderTitle.textContent = state.currentView === 'home' ? 'Ìôà' : 'ÎåÄÌôî';
            }

            // Handle message input bar and bottom nav bar visibility
            if (state.currentView === 'chatMessages') {
                if (messageInputBar) messageInputBar.style.display = 'flex';
                if (bottomNavBar) bottomNavBar.style.display = 'none';
                // Immediately focus the input when entering a chat room
                const messageInput = document.getElementById('message-input');
                if (messageInput) {
                    setTimeout(() => messageInput.focus(), 0);
                }
            } else {
                if (messageInputBar) messageInputBar.style.display = 'none';
                if (bottomNavBar) bottomNavBar.style.display = 'flex';
            }

            // Render dynamic content
            if (state.currentView === 'home') {
                renderHomeView(dynamicContentArea);
            } else if (state.currentView === 'chatRooms') {
                renderChatRoomsView(dynamicContentArea);
            } else if (state.currentView === 'chatMessages') {
                renderMessagesContent(); // Only render messages content here
            } else if (state.currentView === 'opponentProfile') {
                renderOpponentProfileView(dynamicContentArea);
            }

            // Re-setup listeners based on new state, only if Firebase is ready and DB is initialized
            if (isAuthReady && db) {
                setupFirestoreListeners();
            }
        }

        /**
         * Renders the floating chat button.
         */
        function renderChatButton() {
            const container = document.getElementById('chat-float-button-container');
            container.innerHTML = `
                <button id="toggle-chat-button" class="SR_btn SR_text-white SR_rounded-circle SR_d-flex SR_align-items-center SR_justify-content-center SR_shadow-lg transition-all duration-300 ease-in-out transform hover:scale-105" style="width: 56px; height: 56px; background-color: #264790;">
                    <svg style="width: 28px; height: 28px;" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 10h.01M12 10h.01M16 10h.01M9 16H5a2 2 0 00-2-2V6a2 2 0 002-2h14a2 2 0 002 2v8a2 2 0 00-2 2h-5l-5 5v-5z"></path>
                    </svg>
                </button>
            `;
            document.getElementById('toggle-chat-button').onclick = () => setState({ isChatOpen: !state.isChatOpen });
        }

        /**
         * Renders the main chat window.
         * This function now renders the static shell of the chat window.
         * Dynamic content and bar visibility are handled in setState.
         */
        function renderChatWindow() {
            const container = document.getElementById('chat-window-container');
            if (!state.isChatOpen) {
                container.innerHTML = '';
                cleanupFirestoreListeners(); // Unsubscribe listeners when chat is closed
                return;
            }

            // Show loading message if Firebase is not ready (or dummy data is being prepared)
            if (!isAuthReady) {
                container.innerHTML = `
                    <div class="SR_chat-window SR_bg-white SR_shadow-xl SR_d-flex SR_flex-column">
                        <div class="SR_d-flex SR_align-items-center SR_justify-content-center SR_h-100 SR_text-secondary">
                            Î°úÎî© Ï§ë...
                        </div>
                    </div>
                `;
                return;
            }

            // Set chat window class based on maximization state
            const maximizedClass = state.isMaximized ? 'SR_is-maximized' : '';

            // Render the static shell of the chat window
            container.innerHTML = `
                <div id="chat-actual-window" class="SR_chat-window SR_bg-white SR_shadow-xl SR_d-flex SR_flex-column SR_border SR_border-light ${maximizedClass}">
                    <div class="bg-gradient-to-r SR_text-white SR_p-3 SR_rounded-top SR_d-flex SR_align-items-center SR_shadow-sm" style="background: linear-gradient(to right, #1e3c64, #264790);">
                        <button id="back-button" class="SR_btn SR_btn-sm SR_text-white SR_rounded-circle hover-bg-white-opacity-20 SR_transition-colors" style="display: none;">
                            <svg style="width: 24px; height: 24px;" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path>
                            </svg>
                        </button>
                        <h2 id="chat-header-title" class="SR_fs-5 SR_fw-semibold SR_text-truncate SR_flex-grow-1 SR_text-center"></h2>
                        <div class="SR_d-flex SR_align-items-center SR_ms-auto">
                            <button id="maximize-chat-button" class="SR_btn SR_btn-sm SR_text-white SR_rounded-circle hover-bg-white-opacity-20 SR_transition-colors" title="${state.isMaximized ? 'ÏõêÎûòÎåÄÎ°ú' : 'Ï†ÑÏ≤¥ ÌôîÎ©¥'}">
                                ${state.isMaximized ? `
                                    <svg style="width: 24px; height: 24px;" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5v-4m0 0h-4m4 0l-5-5"></path>
                                    </svg>
                                ` : `
                                    <svg style="width: 24px; height: 24px;" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m7-5h4m0 0v4m0-4l-5 5M4 16v4m0 0h4m-4 0l5-5m7 5h4m0 0v-4m0 4l-5-5"></path>
                                    </svg>
                                `}
                            </button>
                            <button id="close-chat-button" class="SR_btn SR_btn-sm SR_text-white SR_rounded-circle hover-bg-white-opacity-20 SR_transition-colors SR_ms-2">
                                <svg style="width: 24px; height: 24px;" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                                </svg>
                            </button>
                        </div>
                    </div>

                    <div id="dynamic-content" class="SR_chat-scroll-area SR_flex-grow-1 SR_p-3">
                        </div>

                    <div id="message-input-bar" class="SR_border-top SR_p-3 SR_d-flex SR_align-items-center" style="display: none;">
                        <input type="text" id="message-input" class="SR_form-control SR_form-control-sm SR_me-2 SR_py-2 SR_ps-4 SR_pe-2 SR_rounded-pill SR_flex-grow-1 SR_text-dark" placeholder="Î©îÏãúÏßÄÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî...">
                        <button id="send-message-button" class="SR_btn SR_bg-primary SR_rounded-circle SR_d-flex SR_align-items-center SR_justify-content-center" style="width: 40px; height: 40px; background-color: #264790;">
                            <svg style="width: 20px; height: 20px;" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3"></path>
                            </svg>
                        </button>
                    </div>

                    <div id="bottom-nav-bar" class="SR_border-top SR_d-flex SR_justify-content-around SR_bg-body-tertiary" style="display: flex;">
                        <button id="nav-home" class="SR_btn SR_flex-fill SR_d-flex SR_flex-column SR_align-items-center SR_p-2 SR_nav-link SR_active">
                            <svg style="width: 24px; height: 24px;" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2 2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6"></path>
                            </svg>
                            <span class="SR_small SR_fw-medium SR_mt-1">Ìôà</span>
                        </button>
                        <button id="nav-chat-rooms" class="SR_btn SR_flex-fill SR_d-flex SR_flex-column SR_align-items-center SR_p-2 SR_nav-link">
                            <svg style="width: 24px; height: 24px;" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 10h.01M12 10h.01M16 10h.01M9 16H5a2 2 0 00-2-2V6a2 2 0 002-2h14a2 2 0 002 2v8a2 2 0 00-2 2h-5l-5 5v-5z"></path>
                            </svg>
                            <span class="SR_small SR_fw-medium SR_mt-1">ÎåÄÌôî</span>
                        </button>
                        <button id="nav-ai-assistant" class="SR_btn SR_flex-fill SR_d-flex SR_flex-column SR_align-items-center SR_p-2 SR_nav-link">
                            <svg style="width: 24px; height: 24px;" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 3v2m6-2v2M9 19v2m6-2v2M5 7h14c2.209 0 4 1.791 4 4v2c0 2.209-1.791 4-4 4H5c-2.209 0-4-1.791-4-4v-2c0-2.209 1.791-4 4-4z"></path>
                            </svg>
                            <span class="SR_small SR_fw-medium SR_mt-1">AI ÎèÑÏö∞ÎØ∏</span>
                        </button>
                        <button id="nav-smart-reply" class="SR_btn SR_flex-fill SR_d-flex SR_flex-column SR_align-items-center SR_p-2 SR_nav-link">
                            <svg style="width: 24px; height: 24px;" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 8h10M7 12h10M7 16h6M8 20L5 17V4a2 2 0 012-2h10a2 2 0 012 2v13l-3 3h-7z"></path>
                            </svg>
                            <span class="SR_small SR_fw-medium SR_mt-1">ÎãµÏû• Ï†úÏïà</span>
                        </button>
                    </div>
                </div>
            `;
            // Add event listeners after rendering (removed for brevity in plan, but would be included in final code)
            document.getElementById('maximize-chat-button').onclick = () => setState({ isMaximized: !state.isMaximized });
            document.getElementById('close-chat-button').onclick = () => setState({ isChatOpen: false });
            document.getElementById('back-button').onclick = () => {
                if (state.currentView === 'chatMessages') {
                    setState({ currentView: 'chatRooms', selectedRoomId: null });
                } else if (state.currentView === 'opponentProfile') {
                    setState({ currentView: 'chatMessages' });
                }
            };
            document.getElementById('send-message-button').onclick = () => {
                const messageInput = document.getElementById('message-input');
                if (messageInput && messageInput.value.trim()) {
                    sendMessage(messageInput.value, userId, `ÏÇ¨Ïö©Ïûê ${userId.substring(0, 4)}`);
                }
            };

            // Navigation button listeners
            document.getElementById('nav-home').onclick = () => setState({ currentView: 'home' });
            document.getElementById('nav-chat-rooms').onclick = () => setState({ currentView: 'chatRooms' });
            document.getElementById('nav-ai-assistant').onclick = () => askAIAssistant();
            document.getElementById('nav-smart-reply').onclick = () => suggestSmartReplies();
        }

        /**
         * Renders the home view content.
         * @param {HTMLElement} container - The container element to render into
         */
        function renderHomeView(container) {
            if (!container) return;
            container.innerHTML = `
                <div class="SR_d-flex SR_flex-column SR_align-items-center SR_justify-content-center SR_h-100 SR_text-center">
                    <svg class="SR_text-secondary SR_mb-3" style="width: 64px; height: 64px;" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 4a2 2 0 11-4 0v1a1 1 0 001 1h3a1 1 0 001-1V4zM16 16c-1.657 0-3 1.343-3 3s1.343 3 3 3 3-1.343 3-3-1.343-3-3-3zM21 12a1 1 0 01-1 1H3a1 1 0 01-1-1V6a1 1 0 011-1h17a1 1 0 011 1v6zM11 16a2 2 0 11-4 0v1a1 1 0 001 1h3a1 1 0 001-1v-1z"></path>
                    </svg>
                    <h3 class="SR_fs-5 SR_fw-semibold SR_text-dark SR_mb-2">ÌôòÏòÅÌï©ÎãàÎã§!</h3>
                    <p class="SR_text-secondary SR_small">ÏïÑÎûò ÌÉêÏÉâ Î©îÎâ¥Î•º ÏÇ¨Ïö©ÌïòÏó¨ Ï±ÑÌåÖÎ∞©ÏùÑ ÌôïÏù∏ÌïòÍ±∞ÎÇò ÏÉàÎ°úÏö¥ ÎåÄÌôîÎ•º ÏãúÏûëÌï† Ïàò ÏûàÏäµÎãàÎã§.</p>
                </div>
            `;
        }

        /**
         * Renders the chat rooms list view.
         * @param {HTMLElement} container - The container element to render into
         */
        function renderChatRoomsView(container) {
            if (!container) return;
            container.innerHTML = `
                <div class="SR_list-group SR_list-group-flush">
                    ${state.chatRooms.map(room => `
                        <a href="#" class="SR_list-group-item SR_list-group-item-action SR_d-block SR_text-decoration-none SR_text-reset SR_py-3 SR_px-4" data-room-id="${room.id}">
                            <div class="SR_d-flex SR_w-100 SR_justify-content-between">
                                <h5 class="SR_mb-1 SR_fs-6 SR_fw-semibold SR_text-dark SR_text-truncate">${room.name}</h5>
                                <small class="SR_text-muted">${room.lastMessageTimestamp ? new Date(room.lastMessageTimestamp.toDate()).toLocaleDateString('ko-KR') : ''}</small>
                            </div>
                            <p class="SR_mb-1 SR_small SR_text-secondary SR_text-truncate">${room.lastMessage}</p>
                        </a>
                    `).join('')}
                    <button id="new-chat-room-button" class="SR_btn SR_btn-info SR_text-white SR_w-100 SR_rounded-bottom SR_py-3">ÏÉà Ï±ÑÌåÖÎ∞© ÎßåÎì§Í∏∞</button>
                </div>
            `;

            // Add event listeners for chat room items
            container.querySelectorAll('[data-room-id]').forEach(item => {
                item.onclick = (e) => {
                    e.preventDefault();
                    const roomId = item.dataset.roomId;
                    setState({ currentView: 'chatMessages', selectedRoomId: roomId });
                };
            });

            // Add event listener for new chat room button
            document.getElementById('new-chat-room-button').onclick = async () => {
                const roomName = await new Promise(resolve => {
                    SR_showModal('ÏÉà Ï±ÑÌåÖÎ∞© ÎßåÎì§Í∏∞', 'Ï±ÑÌåÖÎ∞© Ïù¥Î¶ÑÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî:', true);
                    const confirmButton = document.getElementById('modal-confirm-button');
                    const cancelButton = document.getElementById('modal-cancel-button');
                    const inputField = document.getElementById('modal-input');

                    const handleConfirm = () => {
                        const value = inputField.value.trim();
                        document.getElementById('custom-input-modal-container').remove();
                        resolve(value);
                    };
                    const handleCancel = () => {
                        document.getElementById('custom-input-modal-container').remove();
                        resolve(null);
                    };
                    confirmButton.onclick = handleConfirm;
                    cancelButton.onclick = handleCancel;
                    inputField.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            handleConfirm();
                        }
                    });
                });
                if (roomName) {
                    createNewChatRoom(roomName);
                }
            };
        }

        /**
         * Renders the messages content for the current chat room.
         * This function should be called when `state.messages` changes.
         */
        function renderMessagesContent() {
            const container = document.getElementById('dynamic-content');
            if (!container) return;

            const currentRoom = state.chatRooms.find(r => r.id === state.selectedRoomId);
            const messagesToDisplay = state.messages.length > 0 ? state.messages : (currentRoom ? currentRoom.messages : []);

            container.innerHTML = `
                <div id="chat-messages" class="SR_chat-scroll-area SR_flex-grow-1">
                    ${messagesToDisplay.map(msg => {
                        const isSender = msg.senderId === userId;
                        const isAI = msg.senderId === AI_ASSISTANT_ID;
                        const messageClass = isSender ? 'SR_text-white SR_bg-primary SR_rounded-bottom SR_rounded-start SR_me-auto' :
                                       (isAI ? 'SR_bg-light SR_text-dark SR_rounded-bottom SR_rounded-end SR_ms-auto' :
                                               'SR_bg-light SR_text-dark SR_rounded-bottom SR_rounded-end SR_ms-auto');
                        const alignmentClass = isSender ? 'SR_text-end' : 'SR_text-start';
                        const avatarSrc = dummyUserProfiles[msg.senderId]?.profileImageUrl || (isSender ? `https://placehold.co/80x80/6366f1/ffffff?text=${msg.senderName.substring(0, 2)}` : `https://placehold.co/80x80/6c757d/ffffff?text=${msg.senderName.substring(0, 2)}`);

                        return `
                            <div class="SR_d-flex ${alignmentClass} SR_mb-2">
                                ${!isSender ? `
                                    <img src="${avatarSrc}" alt="${msg.senderName}" class="SR_rounded-circle SR_me-2" style="width: 32px; height: 32px;">
                                ` : ''}
                                <div class="SR_d-flex SR_flex-column">
                                    <div class="SR_small SR_text-muted ${isSender ? 'SR_text-end' : 'SR_text-start'}">${msg.senderName}</div>
                                    <div class="SR_px-3 SR_py-2 SR_rounded-3 SR_text-wrap ${messageClass}" style="max-width: 80%;">
                                        ${msg.text}
                                        ${msg.isPending ? ` <span class="SR_small SR_text-muted">(Ï†ÑÏÜ° Ï§ë...)</span>` : ''}
                                    </div>
                                    <div class="SR_small SR_text-muted SR_mt-1 ${isSender ? 'SR_text-end' : 'SR_text-start'}">
                                        ${msg.timestamp ? new Date(msg.timestamp.toDate()).toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit' }) : ''}
                                    </div>
                                </div>
                                ${isSender ? `
                                    <img src="${avatarSrc}" alt="${msg.senderName}" class="SR_rounded-circle SR_ms-2" style="width: 32px; height: 32px;">
                                ` : ''}
                            </div>
                        `;
                    }).join('')}
                </div>
                <div id="reply-suggestions" class="SR_d-flex SR_flex-wrap gap-2 SR_mt-3 SR_mb-2 SR_px-3"></div>
            `;
            scrollToBottom();
        }

        /**
         * Renders the opponent's profile view.
         * @param {HTMLElement} container - The container element to render into
         */
        function renderOpponentProfileView(container) {
            if (!container) return;

            const opponentId = state.selectedOpponentId;
            const opponentProfile = dummyUserProfiles[opponentId];

            if (!opponentProfile) {
                container.innerHTML = `<div class="SR_text-center SR_text-secondary SR_py-5">ÌîÑÎ°úÌïÑ Ï†ïÎ≥¥Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.</div>`;
                return;
            }

            container.innerHTML = `
                <div class="SR_d-flex SR_flex-column SR_align-items-center SR_p-4">
                    <img src="${opponentProfile.profileImageUrl}" alt="${opponentProfile.name}" class="SR_rounded-circle SR_mb-3 SR_shadow-sm" style="width: 96px; height: 96px;">
                    <h3 class="SR_fs-5 SR_fw-semibold SR_text-dark SR_mb-1">${opponentProfile.name}</h3>
                    <p class="SR_text-secondary SR_small SR_mb-3">${opponentProfile.company}</p>
                    <p class="SR_text-dark SR_text-center SR_px-3">${opponentProfile.description}</p>

                    <h4 class="SR_fs-6 SR_fw-semibold SR_text-dark SR_mt-4 SR_mb-3">Ìè¨Ìä∏Ìè¥Î¶¨Ïò§</h4>
                    <div id="opponent-portfolio-carousel-container" class="SR_w-100 SR_position-relative">
                        <div id="opponent-portfolio-carousel" class="SR_d-flex SR_overflow-auto SR_hide-scrollbar" style="scroll-snap-type: x mandatory;">
                            ${dummyPortfolios.map(p => `
                                <div class="SR_mx-2 SR_p-2 SR_card SR_shadow-sm" style="min-width: 180px; scroll-snap-align: start;">
                                    <img src="${p.imageUrl}" class="SR_card-img-top SR_rounded SR_mb-2" alt="${p.title}">
                                    <div class="SR_card-body SR_p-0">
                                        <h5 class="SR_fs-6 SR_fw-semibold SR_text-truncate SR_mb-1">${p.title}</h5>
                                        <p class="SR_text-muted SR_small">${p.description.substring(0, 50)}...</p>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                        <button id="opponent-portfolio-scroll-left" class="SR_btn SR_btn-sm SR_rounded-circle SR_position-absolute SR_top-50 SR_start-0 translate-middle-y SR_shadow-lg" style="background-color: rgba(255,255,255,0.8); display: none;">&lt;</button>
                        <button id="opponent-portfolio-scroll-right" class="SR_btn SR_btn-sm SR_rounded-circle SR_position-absolute SR_top-50 SR_end-0 translate-middle-y SR_shadow-lg" style="background-color: rgba(255,255,255,0.8); display: none;">&gt;</button>
                    </div>

                    <h4 class="SR_fs-6 SR_fw-semibold SR_text-dark SR_mt-4 SR_mb-3">Ïô∏Ï£º ÌîÑÎ°úÏ†ùÌä∏</h4>
                    <div id="opponent-outsourcing-carousel-container" class="SR_w-100 SR_position-relative">
                        <div id="opponent-outsourcing-carousel" class="SR_d-flex SR_overflow-auto SR_hide-scrollbar" style="scroll-snap-type: x mandatory;">
                            ${dummyOutsourcings.map(o => `
                                <div class="SR_mx-2 SR_p-2 SR_card SR_shadow-sm" style="min-width: 180px; scroll-snap-align: start;">
                                    <div class="SR_card-body SR_p-0">
                                        <h5 class="SR_fs-6 SR_fw-semibold SR_text-truncate SR_mb-1">${o.title}</h5>
                                        <p class="SR_small SR_text-muted SR_mb-2">${o.description.substring(0, 50)}...</p>
                                        ${o.status === 'ÏßÑÌñâ Ï§ë' ? `<span class="badge SR_bg-info SR_text-dark">ÏßÑÌñâ Ï§ë</span>` :
                                          o.status === 'ÎåÄÍ∏∞ Ï§ë' ? `<span class="badge SR_bg-warning SR_text-dark">ÎåÄÍ∏∞ Ï§ë</span>` :
                                          o.status === 'ÏôÑÎ£å' ? `<span class="badge SR_bg-success SR_text-white">ÏôÑÎ£å</span>` : ''}
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                        <button id="opponent-outsourcing-scroll-left" class="SR_btn SR_btn-sm SR_rounded-circle SR_position-absolute SR_top-50 SR_start-0 translate-middle-y SR_shadow-lg" style="background-color: rgba(255,255,255,0.8); display: none;">&lt;</button>
                        <button id="opponent-outsourcing-scroll-right" class="SR_btn SR_btn-sm SR_rounded-circle SR_position-absolute SR_top-50 SR_end-0 translate-middle-y SR_shadow-lg" style="background-color: rgba(255,255,255,0.8); display: none;">&gt;</button>
                    </div>
                </div>
            `;

            // Setup carousel scroll buttons (basic functionality)
            const opponentPortfolioCarousel = document.getElementById('opponent-portfolio-carousel');
            const opponentOutsourcingCarousel = document.getElementById('opponent-outsourcing-carousel');

            if (opponentPortfolioCarousel) {
                document.getElementById('opponent-portfolio-scroll-left').onclick = () => {
                    opponentPortfolioCarousel.scrollBy({ left: -200, behavior: 'smooth' });
                };
                document.getElementById('opponent-portfolio-scroll-right').onclick = () => {
                    opponentPortfolioCarousel.scrollBy({ left: 200, behavior: 'smooth' });
                };
            }
            if (opponentOutsourcingCarousel) {
                document.getElementById('opponent-outsourcing-scroll-left').onclick = () => {
                    opponentOutsourcingCarousel.scrollBy({ left: -200, behavior: 'smooth' });
                };
                document.getElementById('opponent-outsourcing-scroll-right').onclick = () => {
                    opponentOutsourcingCarousel.scrollBy({ left: 200, behavior: 'smooth' });
                };
            }
        }


        // Function to render the entire app
        function render() {
            renderChatButton();
            renderChatWindow(); // This now renders the static shell and sets up initial listeners
        }


        // Start Firebase initialization and app rendering when the window loads
        window.onload = function() {
            initializeFirebase();
            render(); // Initial button render
        };
    </script>
</div>
</html>